---
title: Migrer de ASP.NET Core 2,2 à 3,0
author: rick-anderson
description: Découvrez comment migrer un projet ASP.NET Core 2,2 vers ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 11/12/2019
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: e8f22c3e7b82b84afe513bf495ff5a46a527bb73
ms.sourcegitcommit: 231780c8d7848943e5e9fd55e93f437f7e5a371d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/15/2019
ms.locfileid: "74116068"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2,2 à 3,0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2,2 existant vers ASP.NET Core 3,0.

## <a name="prerequisites"></a>Configuration requise

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Mettre à jour la version du SDK .NET Core dans global.json

Si votre solution repose sur un fichier [global. JSON](/dotnet/core/tools/global-json) pour cibler une version spécifique de kit SDK .net Core, mettez à jour sa propriété `version` sur la version 3,0 installée sur votre ordinateur :

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

### <a name="update-the-target-framework"></a>Mettre à jour la version cible de .NET Framework

ASP.NET Core 3,0 et versions ultérieures s’exécutent uniquement sur .NET Core. Définissez le [moniker du Framework cible (TFM)](/dotnet/standard/frameworks) sur `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Supprimer les références de package obsolètes

ASP.NET Core ne produit plus un grand nombre de fonctionnalités de packages NuGet. Ces références de package doivent être supprimées de votre fichier projet. Par exemple, le fichier projet généré par modèle pour une application Web ASP.NET Core 2,2 :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Fichier de projet ASP.NET Core 3,0 mis à jour :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Fichier de projet ASP.NET Core 3,0 mis à jour :

* Dans la `<PropertyGroup>` :

  * Met à jour TFM sur `netcoreapp3.0`
  * Supprime l’élément `<AspNetCoreHostingModel>`. Pour plus d’informations, consultez [modèle d’hébergement in-process](#in-process-hosting-model) dans ce document.

* Dans la `<ItemGroup>` :

  * `Microsoft.AspNetCore.App` est supprimé. Pour plus d’informations, consultez Référence de l' [infrastructure](#framework-reference) dans ce document.
  * `Microsoft.AspNetCore.Razor.Design` est supprimée et la liste suivante de packages n’est plus produite.

Pour afficher la liste complète des packages qui ne sont plus produits, sélectionnez la liste de développement suivante :

<details>
    <summary>Cliquez ici pour développer la liste des packages qui ne sont plus produits</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore.SignalR. Ebauche</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. en-têtes</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Examiner les modifications avec rupture

[Examiner les modifications avec rupture](#break)

### <a name="framework-reference"></a>Référence du Framework

Les fonctionnalités de ASP.NET Core qui étaient disponibles via l’un des packages répertoriés ci-dessus sont disponibles dans le cadre du `Microsoft.AspNetCore.App` Framework partagé. L' *infrastructure partagée* est l’ensemble d’assemblys (fichiers *. dll* ) qui sont installés sur l’ordinateur et qui comprend un composant d’exécution et un pack de ciblage. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les projets qui ciblent le kit de développement logiciel (SDK) `Microsoft.NET.Sdk.Web` référencent implicitement l’infrastructure `Microsoft.AspNetCore.App`.

  Aucune référence supplémentaire n’est requise pour ces projets :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Les projets qui ciblent `Microsoft.NET.Sdk` ou `Microsoft.NET.Sdk.Razor` SDK doivent ajouter un `FrameworkReference` explicite à `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Builds dépendantes du Framework utilisant l’ancrage

Les builds dépendantes du Framework des applications console qui utilisent un package qui dépend de l' [infrastructure partagée](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.net Core peuvent fournir l’erreur d’exécution suivante :

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` est l’infrastructure partagée contenant le runtime ASP.NET Core et est uniquement présente sur l’image de l’ancrage [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  Le kit de développement logiciel (SDK) 3,0 réduit la taille des builds dépendantes de l’infrastructure à l’aide de asp.net core en n’incluant pas de copies en double des bibliothèques disponibles dans le Framework partagé.  Il s’agit d’une économie potentielle pouvant atteindre 18 Mo, mais exige que le runtime ASP.NET Core soit présent/installé pour exécuter l’application.

Pour déterminer si l’application a une dépendance (directe ou indirecte) sur le ASP.NET Core Framework partagé, examinez le fichier *runtimeconfig. JSON* généré pendant une génération/publication de votre application. Le fichier JSON suivant illustre une dépendance sur le ASP.NET Core Framework partagé :

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si votre application utilise la station d’accueil, utilisez une image de base qui comprend ASP.NET Core 3,0. Par exemple, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Ajouter des références de package pour les assemblys supprimés

ASP.NET Core 3,0 supprime certains assemblys qui faisaient auparavant partie de la référence de package `Microsoft.AspNetCore.App`. Pour continuer à utiliser les fonctionnalités fournies par ces assemblys, référencez les versions 3,0 des packages correspondants :

* Une application Web générée par modèle avec des **comptes d’utilisateur individuels** nécessite l’ajout des packages suivants :

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Pour plus d’informations sur le référencement du package spécifique au fournisseur de base de données, consultez [fournisseurs de bases de données](/ef/core/providers/index).

* Interface utilisateur d’identité

  La prise en charge de l' [interface utilisateur d’identité](xref:security/authentication/identity) peut être ajoutée en référençant le package [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Services SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* L’authentification &ndash; la prise en charge des flux d’authentification tiers est disponible sous forme de packages NuGet :

  * OAuth Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Jeton du porteur OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Authentification de compte Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Authentification OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Authentification WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Prise en charge de la mise en forme et de la négociation de contenu pour `System.Net.HttpClient` &ndash; le package NuGet [Microsoft. Aspnet. WebApi. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fournit une extensibilité utile pour `System.Net.HttpClient` avec des API telles que `ReadAsAsync`, `PostJsonAsync`, etc.

* La compilation du runtime Razor &ndash; la prise en charge de la compilation des vues et des pages Razor fait désormais partie de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Prise en charge de MVC `Newtonsoft.Json` &ndash; la prise en charge de l’utilisation de MVC avec `Newtonsoft.Json` fait désormais partie de [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Modifications au démarrage

L’illustration suivante montre les lignes supprimées et modifiées dans une application Web ASP.NET Core 2,2 Razor Pages :

![lignes supprimées et modifiées dans une application Web Razor ASP.NET Core 2,2](22-to-30/_static/startup2.2.png)

Dans l’image précédente, le code supprimé est affiché en rouge. Le code supprimé n’affiche pas le code des options de cookie, qui a été supprimé avant la comparaison des fichiers.

L’illustration suivante montre les lignes ajoutées et modifiées dans une application Web ASP.NET Core 3,0 Razor Pages :

![lignes ajoutées et modifiées dans une application Web Razor ASP.NET Core 3,0](22-to-30/_static/startup3.0.png)

Dans l’image précédente, le code ajouté est affiché en vert. Pour plus d’informations sur les modifications suivantes :

* `services.AddMvc` à `services.AddRazorPages`, consultez [inscription du service MVC](#mvc-service-registration) dans ce document.
* `CompatibilityVersion`, consultez <xref:mvc/compatibility-version>.
* `IHostingEnvironment` à `IWebHostEnvironment`, consultez [cette annonce GitHub](https://github.com/aspnet/AspNetCore/issues/7749).
* `app.UseAuthorization` a été ajouté aux modèles pour montrer que l’intergiciel d’autorisation de commande doit être ajouté. Si l’application n’utilise pas l’autorisation, vous pouvez supprimer l’appel à `app.UseAuthorization` en toute sécurité.
* `app.UseEndpoints`, consultez [Razor pages](#razor-pages) ou [migrer Startup. configure](#migrate-startupconfigure) dans ce document.

### <a name="analyzer-support"></a>Prise en charge de l’analyseur

Les projets qui ciblent des analyseurs de référence `Microsoft.NET.Sdk.Web` de manière implicite ont été fournis précédemment dans le cadre du package [Microsoft. AspNetCore. Mvc. Analysis](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Aucune référence supplémentaire n’est requise pour les activer.

Si votre application utilise des [analyseurs d’API](xref:web-api/advanced/analyzers) livrés précédemment à l’aide du package [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , modifiez votre fichier projet pour référencer les analyseurs fournis dans le cadre du kit de développement logiciel (SDK) Web .net Core :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Bibliothèque de classes Razor

Les projets de bibliothèque de classes Razor qui fournissent des composants d’interface utilisateur pour MVC doivent définir la propriété `AddRazorSupportForMvc` dans le fichier projet :

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modèle d’hébergement in-process

Les projets sont par défaut du [modèle d’hébergement in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.net Core 3,0 ou version ultérieure. Vous pouvez éventuellement supprimer la propriété `<AspNetCoreHostingModel>` dans le fichier projet si sa valeur est `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

Migrer la configuration Kestrel vers le générateur d’hôte Web fourni par `ConfigureWebHostDefaults` (*Program.cs*) :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si l’application crée l’hôte manuellement avec `HostBuilder`, appelez `UseKestrel` sur le générateur d’hôte Web dans `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>L’intergiciel de connexion remplace les adaptateurs de connexion

Les adaptateurs de connexion (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) ont été supprimés de Kestrel. Remplacer les adaptateurs de connexion par un intergiciel de connexion. L’intergiciel de connexion est similaire à l’intergiciel (middleware) HTTP dans le pipeline ASP.NET Core, mais pour les connexions de niveau inférieur. Journalisation HTTPs et connexion :

* Ont été déplacés des adaptateurs de connexion vers l’intergiciel de connexion.
* Ces méthodes d’extension fonctionnent comme dans les versions précédentes de ASP.NET Core. 

Pour plus d’informations, consultez [l’exemple TlsFilterConnectionHandler dans la section ListenOptions. Protocols de l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstractions de transport déplacées et rendues publiques

La couche de transport Kestrel a été exposée en tant qu’interface publique dans `Connections.Abstractions`. Dans le cadre de ces mises à jour :

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` et les types associés ont été supprimés.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> a été déplacé de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> vers les options de transport.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` a été supprimé de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Pour plus d’informations, consultez les ressources GitHub suivantes :

* [Abstractions de réseau client/serveur (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implémenter l’abstraction de l’écouteur socle et plat Kestrel en haut (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>En-têtes de la demande Kestrel

Pour les applications qui ciblent des versions antérieures de ASP.NET Core :

* Kestrel ajoute des en-têtes de code de fin en bloc HTTP/1.1 dans la collection d’en-têtes de demande.
* Les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Cela pose des problèmes d’ambiguïté entre les en-têtes et les codes de fin, de sorte que les codes de fin ont été déplacés vers une nouvelle collection (`RequestTrailerExtensions`) dans 3,0.

Les codes de fin de requête HTTP/2 sont :

* Non disponible dans ASP.NET Core 2,2.
* Disponible dans 3,0 en tant que `RequestTrailerExtensions`.

De nouvelles méthodes d’extension de demande sont présentes pour accéder à ces codes de fin. Comme avec HTTP/1.1, les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Pour la version 3,0, les méthodes `RequestTrailerExtensions` suivantes sont disponibles :

* `GetDeclaredTrailers` &ndash; obtient l’en-tête Request `Trailer` qui répertorie les codes de fin à attendre après le corps.
* `SupportsTrailers` &ndash; indique si la demande prend en charge la réception des en-têtes de code de fin.
* `CheckTrailersAvailable` &ndash; vérifie si la demande prend en charge les codes de fin et s’ils sont disponibles pour la lecture. Cette vérification ne suppose pas qu’il y a des codes de fin à lire. Il se peut qu’il n’y ait aucune remorque à lire même si `true` est retourné par cette méthode.
* `GetTrailer` &ndash; obtient l’en-tête de fin demandé de la réponse. Vérifiez `SupportsTrailers` avant d’appeler `GetTrailer`, ou un <xref:System.NotSupportedException> peut se produire si la requête ne prend pas en charge les en-têtes de fin.

Pour plus d’informations, consultez [put Request queues in a distinct collection (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO désactivé

`AllowSynchronousIO` active ou désactive les API d’e/s synchrones, telles que `HttpRequest.Body.Read`, `HttpResponse.Body.Write` et `Stream.Flush`. Ces API sont une source de privation de thread conduisant à des blocages d’application. Dans 3,0, `AllowSynchronousIO` est désactivé par défaut. Pour plus d’informations, consultez [la section e/s synchrone dans l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Si des e/s synchrones sont nécessaires, vous pouvez les activer en configurant l’option `AllowSynchronousIO` sur le serveur utilisé (lors de l’appel de `ConfigureKestrel`, par exemple, si vous utilisez Kestrel). Notez que les serveurs (Kestrel, HttpSys, TestServer, etc.) ont leur propre `AllowSynchronousIO` option qui n’affectera pas les autres serveurs. Les e/s synchrones peuvent être activées pour tous les serveurs par demande à l’aide de l’option `IHttpBodyControlFeature.AllowSynchronousIO` :

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si vous rencontrez des problèmes avec les implémentations de <xref:System.IO.TextWriter> ou d’autres flux qui appellent des API synchrones dans [dispose](/dotnet/standard/garbage-collection/implementing-dispose), appelez plutôt la nouvelle API <xref:System.IO.Stream.DisposeAsync*>.

Pour plus d’informations, consultez [[Announcement] AllowSynchronousIO disabled in All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https supprimé

Dans ASP.NET Core 2,1, le contenu de *Microsoft. AspNetCore. Server. Kestrel. https. dll* a été déplacé vers *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Il s’agissait d’une mise à jour sans rupture utilisant des attributs `TypeForwardedTo`. Pour 3,0, l’assembly vide *Microsoft. AspNetCore. Server. Kestrel. https. dll* et le package NuGet ont été supprimés.

Les bibliothèques référençant [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) doivent mettre à jour les dépendances de ASP.NET Core à 2,1 ou une version ultérieure.

Les applications et les bibliothèques qui ciblent ASP.NET Core 2,1 ou version ultérieure doivent supprimer toutes les références directes au package [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Support Json.NET

Dans le cadre du travail d' [amélioration du ASP.net Core Framework partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de la ASP.net Core Framework partagé.

La valeur par défaut pour ASP.NET Core est désormais [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), qui est une nouveauté de .net Core 3,0. Envisagez d’utiliser `System.Text.Json` dans la mesure du possible. Elle est très performante et ne nécessite pas de dépendance de bibliothèque supplémentaire. Toutefois, étant donné que `System.Text.Json` est nouveau, il est possible qu’il manque actuellement des fonctionnalités dont votre application a besoin.

Votre application peut nécessiter une intégration `Newtonsoft.Json` si elle utilise des fonctionnalités spécifiques à `Newtonsoft.Json` telles que JsonPatch ou Converters, ou si elle [met en forme](xref:web-api/advanced/formatting) des types spécifiques à `Newtonsoft.Json`.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0 SignalR, consultez [basculer vers Newtonsoft. JSON](#switch-to-newtonsoftjson) dans ce document.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0 :

* Ajoutez une référence de package à [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Mettez à jour `Startup.ConfigureServices` pour appeler `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` est compatible avec les nouvelles méthodes d’inscription de service MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Les paramètres Json.NET peuvent être définis dans l’appel à `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Inscription du service MVC

ASP.NET Core 3,0 ajoute de nouvelles options pour l’inscription des scénarios MVC dans `Startup.ConfigureServices`.

Trois nouvelles méthodes d’extension de niveau supérieur liées aux scénarios MVC sur `IServiceCollection` sont disponibles. Les modèles utilisent ces nouvelles méthodes au lieu de `AddMvc`. Toutefois, `AddMvc` continue à se comporter comme dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas aux vues ou aux pages. Le modèle d’API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge de Razor Pages et de la prise en charge minimale du contrôleur. Le modèle d’application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l’appel de `AddMvc` dans ASP.NET Core 2,2 :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routage du code de démarrage

Si une application appelle `UseMvc` ou `UseSignalR`, migrez l’application vers le [routage des points de terminaison](xref:fundamentals/routing) , si possible. Pour améliorer la compatibilité du routage des points de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines des modifications apportées à la génération d’URL introduites dans ASP.NET Core 2,2. Si vous avez rencontré des problèmes lors de l’utilisation du routage de point de terminaison dans 2,2, attendez-vous à des améliorations de ASP.NET Core 3,0, avec les exceptions suivantes :

* Si l’application implémente `IRouter` ou hérite de `Route`, utilisez [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) comme remplacement.

* Si l’application accède directement à `RouteData.Routers` dans MVC pour analyser des URL, vous pouvez remplacer ceci par l’utilisation de `LinkParser.ParsePathByEndpointName`. 
 * Définissez l’itinéraire avec un nom d’itinéraire.
 * Utilisez `LinkParser.ParsePathByEndpointName` et transmettez le nom de l’itinéraire souhaité.

Le routage des points de terminaison prend en charge les mêmes syntaxe de modèle d’itinéraire et fonctionnalités de création de modèle de routage que `IRouter`. Le routage des points de terminaison prend en charge `IRouteConstraint`. Le routage des points de terminaison prend en charge `[Route]`, `[HttpGet]`et les autres attributs de routage MVC.

Pour la plupart des applications, seul `Startup` nécessite des modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup. configure

Conseils généraux :

* Ajoutez `UseRouting`.
* Si l’application appelle `UseStaticFiles`, placez `UseStaticFiles` **avant** `UseRouting`.
* Si l’application utilise des fonctionnalités d’authentification/d’autorisation, telles que `AuthorizePage` ou `[Authorize]`, placez l’appel à `UseAuthentication` et `UseAuthorization`: **after**, `UseRouting` et `UseCors`, mais avant `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Remplacez `UseMvc` ou `UseSignalR` par `UseEndpoints`.
* Si l’application utilise des scénarios [cors](xref:security/cors) , tels que `[EnableCors]`, placez l’appel à `UseCors` avant tout autre intergiciel qui utilise cors (par exemple, placez `UseCors` avant `UseAuthentication`, `UseAuthorization`et `UseEndpoints`).
* Remplacez `IHostingEnvironment` par `IWebHostEnvironment` et ajoutez une instruction `using` pour l’espace de noms <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Remplacez `IApplicationLifetime` par <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (espace de noms <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Remplacez `EnvironmentName` par <xref:Microsoft.Extensions.Hosting.Environments> (espace de noms <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Le code suivant est un exemple de `Startup.Configure` dans une application ASP.NET Core 2,2 classique :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour du code `Startup.Configure` précédent :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pour la plupart des applications, les appels à `UseAuthentication`, `UseAuthorization` et `UseCors` doivent apparaître entre les appels à `UseRouting` et `UseEndpoints` pour être effectifs.

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité utilisent le routage de point de terminaison avec l’hôte générique. Dans `Startup.Configure`, appelez `MapHealthChecks` sur le générateur de point de terminaison à l’aide de l’URL de point de terminaison ou du chemin d’accès relatif :

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Les points de terminaison de contrôle d’intégrité peuvent :

* Spécifiez un ou plusieurs hôtes/ports autorisés.
* Exiger une autorisation.
* Exiger CORS.

Pour plus d'informations, consultez <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Aide sur le middleware de sécurité

La prise en charge de l’autorisation et de CORS est unifiée autour de l’approche de l' [intergiciel (middleware](xref:fundamentals/middleware/index) ). Cela permet d’utiliser les mêmes intergiciels et fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation mis à jour est fourni dans cette version, et l’intergiciel (middleware) CORS est amélioré afin de pouvoir comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. L’intergiciel était fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC devaient être utilisés **sans** l’intergiciel dans d’autres cas d’usage. Avec ASP.NET Core 3,0, nous recommandons que toutes les applications qui requièrent CORS utilisent l’intergiciel (middleware) CORS en tandem avec le routage du point de terminaison. `UseCors` peut être fourni avec une stratégie par défaut et les attributs `[EnableCors]` et `[DisableCors]` peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire.

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison avec la stratégie nommée `default`.
* La classe `MyController` désactive CORS avec l’attribut `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisation

Dans les versions antérieures de ASP.NET Core, la prise en charge de l’autorisation a été fournie via l’attribut `[Authorize]`. L’intergiciel d’autorisation n’est pas disponible. Dans ASP.NET Core 3,0, l’intergiciel (middleware) d’autorisation est requis. Nous vous recommandons de placer le ASP.NET Core middleware d’autorisation (`UseAuthorization`) immédiatement après `UseAuthentication`. L’intergiciel d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.NET Core 3,0 ou version ultérieure, `UseAuthorization` est appelé dans `Startup.Configure`, et l' `HomeController` suivante nécessite un utilisateur connecté :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si l’application utilise un `AuthorizeFilter` comme filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie dans l’appel à `AddAuthorization`.

La `DefaultPolicy` est initialement configurée pour exiger l’authentification, de sorte qu’aucune configuration supplémentaire n’est requise. Dans l’exemple suivant, les points de terminaison MVC sont marqués comme étant `RequireAuthorization`, de sorte que toutes les requêtes doivent être autorisées en fonction de la `DefaultPolicy`. Toutefois, l' `HomeController` autorise l’accès sans que l’utilisateur se connecte à l’application en raison d' `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Les stratégies peuvent également être personnalisées. En s’appuyant sur l’exemple précédent, le `DefaultPolicy` est configuré pour exiger une authentification et une étendue spécifique :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Sinon, tous les points de terminaison peuvent être configurés pour exiger une autorisation sans `[Authorize]` ou `RequireAuthorization` en configurant un `FallbackPolicy`. La `FallbackPolicy` est différente de la `DefaultPolicy`. Le `DefaultPolicy` est déclenché par `[Authorize]` ou `RequireAuthorization`, tandis que le `FallbackPolicy` est déclenché quand aucune autre stratégie n’est définie. `FallbackPolicy` est initialement configuré pour autoriser les demandes sans autorisation.

L’exemple suivant est identique à l’exemple précédent `DefaultPolicy` mais utilise le `FallbackPolicy` pour toujours exiger l’authentification sur tous les points de terminaison, sauf lorsque `[AllowAnonymous]` est spécifié :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L’autorisation par intergiciel fonctionne sans que l’infrastructure ait une connaissance spécifique de l’autorisation. Par exemple, les [contrôles d’intégrité](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

En outre, chaque point de terminaison peut personnaliser ses exigences d’autorisation. Dans l’exemple suivant, `UseAuthorization` traite l’autorisation avec la `DefaultPolicy`, mais le point de terminaison de contrôle d’intégrité `/healthz` nécessite un utilisateur `admin` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est implémentée pour certains scénarios. L’intergiciel (middleware) de points de terminaison lève une exception si une stratégie d’autorisation ou CORS est ignorée en raison d’un intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incompatible est en cours.

#### <a name="custom-authorization-handlers"></a>Gestionnaires d’autorisations personnalisés

Si l’application utilise des [gestionnaires d’autorisations](xref:security/authorization/policies#authorization-handlers)personnalisés, sachez que le routage des points de terminaison passe un type de ressource différent aux gestionnaires que Mvc. Les gestionnaires qui attendent que la ressource de contexte du gestionnaire d’autorisations soit de type <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (le type de ressource [fourni par les filtres MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)) doivent être mis à jour pour gérer les ressources de type <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (le type de ressource donné aux gestionnaires d’autorisation par routage de point de terminaison).

MVC utilise toujours `AuthorizationFilterContext` ressources. ainsi, si l’application utilise des filtres d’autorisation MVC avec l’autorisation de routage de point de terminaison, il peut être nécessaire de gérer les deux types de ressources.

### SignalR

Le mappage de SignalR hubs s’effectue désormais dans `UseEndpoints`.

Mappez chaque concentrateur avec `MapHub`. Comme dans les versions précédentes, chaque concentrateur est explicitement listé.

Dans l’exemple suivant, la prise en charge du Hub `ChatHub` SignalR est ajoutée :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Une nouvelle option permet de contrôler les limites de taille des messages des clients. Par exemple, dans `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Dans ASP.NET Core 2,2, vous pouvez définir le `TransportMaxBufferSize` et cela permet de contrôler la taille de message maximale. Dans ASP.NET Core 3,0, cette option contrôle désormais uniquement la taille maximale avant que la contre-pression soit observée.

### <a name="mvc-controllers"></a>Contrôleurs MVC

Le mappage de contrôleurs a maintenant lieu dans `UseEndpoints`.

Ajoutez `MapControllers` si l’application utilise le routage d’attributs. Dans la mesure où le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3,0 ou version ultérieure, l’ajout de contrôleurs routés par attribut est un abonnement.

Remplacez ce qui suit :

* `MapRoute` avec `MapControllerRoute`
* `MapAreaRoute` avec `MapAreaControllerRoute`

Étant donné que le routage inclut désormais une prise en charge de plus que MVC, la terminologie a changé pour indiquer clairement ce qu’ils font. Les itinéraires conventionnels tels que les `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` sont appliqués dans l’ordre dans lequel ils sont ajoutés. Placez d’abord des itinéraires plus spécifiques (tels que des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers` ajoute la prise en charge des contrôleurs routés par attribut.
* `MapAreaControllerRoute` ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute` ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Suppression du suffixe Async des noms d’action du contrôleur

Dans ASP.NET Core 3,0, ASP.NET Core MVC supprime le suffixe `Async` des noms d’action du contrôleur. Le routage et la génération de liens sont affectés par cette nouvelle valeur par défaut. Exemple :

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Avant ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/ListAsync* .
* Génération de lien requise spécifiant le suffixe `Async`. Exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

Dans ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/List* .
* La génération de liens ne nécessite pas la spécification du suffixe `Async`. Exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Cette modification n’affecte pas les noms spécifiés à l’aide de l’attribut [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Le comportement par défaut peut être désactivé avec le code suivant dans `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Modifications apportées à la génération de liens

Comme expliqué dans la documentation sur les [différences par rapport aux versions antérieures du routage](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), il existe quelques différences dans la génération de liens (à l’aide de `Url.Link` et d’API similaires, par exemple). Elles incluent notamment les suivantes :

* Par défaut, lors de l’utilisation du routage de point de terminaison, la casse des paramètres d’itinéraire dans les URI générés n’est pas nécessairement préservée. Ce comportement peut être contrôlé à l’aide de l’interface `IOutboundParameterTransformer`.
* La génération d’un URI pour un itinéraire non valide (un contrôleur/une action ou une page qui n’existe pas) produira une chaîne vide sous le routage de point de terminaison au lieu de produire un URI non valide.
* Les valeurs ambiantes (paramètres d’itinéraire du contexte actuel) ne sont pas utilisées automatiquement dans la génération de liens avec le routage de point de terminaison. Précédemment, lors de la génération d’un lien vers une autre action (ou page), les valeurs d’itinéraire non spécifiées seraient déduites des valeurs ambiantes des itinéraires *actuels* . Lorsque vous utilisez le routage de point de terminaison, tous les paramètres de routage doivent être spécifiés explicitement lors de la génération de liens.

### <a name="razor-pages"></a>Pages Razor

Le mappage de Razor Pages a maintenant lieu à l’intérieur de `UseEndpoints`.

Ajoutez `MapRazorPages` si l’application utilise Razor Pages. Dans la mesure où le routage des points de terminaison inclut la prise en charge de nombreuses infrastructures, l’ajout de Razor Pages est désormais un abonnement.

Dans la méthode `Startup.Configure` suivante, `MapRazorPages` ajoute la prise en charge de Razor Pages :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

L’utilisation de MVC via `UseMvc` ou `UseMvcWithDefaultRoute` dans ASP.NET Core 3,0 requiert un abonnement explicite à l’intérieur de `Startup.ConfigureServices`. Cela est nécessaire, car MVC doit savoir s’il peut reposer sur l’autorisation et l’intergiciel CORS pendant l’initialisation. Un analyseur est fourni pour avertir si l’application tente d’utiliser une configuration non prise en charge.

Si l’application nécessite la prise en charge de l’ancien `IRouter`, désactivez `EnableEndpointRouting` à l’aide de l’une des approches suivantes dans `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité peuvent être utilisés en tant que *routeur* avec routage des points de terminaison.

Ajoutez `MapHealthChecks` pour utiliser les contrôles d’intégrité avec le routage des points de terminaison. La méthode `MapHealthChecks` accepte des arguments similaires à `UseHealthChecks`. L’avantage de l’utilisation de `MapHealthChecks` sur `UseHealthChecks` est la possibilité d’appliquer une autorisation et de bénéficier d’un contrôle plus précis de la stratégie de correspondance.

Dans l’exemple suivant, `MapHealthChecks` est appelé pour un point de terminaison de contrôle d’intégrité à `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3,0 utilisent l' [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient l' [hôte Web](xref:fundamentals/host/web-host). Le code suivant illustre le modèle ASP.NET Core 3,0 généré `Program` Class :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant illustre la classe `Program` générée par le modèle ASP.NET Core 2,2 :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> reste dans 3,0 et est le type de la `webBuilder` visible dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> sera dépréciée dans une version ultérieure et remplacée par `HostBuilder`.

La modification la plus significative entre `WebHostBuilder` et `HostBuilder` est dans l' [injection de dépendances (di)](xref:fundamentals/dependency-injection). Lorsque vous utilisez `HostBuilder`, vous pouvez uniquement injecter les éléments suivants dans le constructeur de `Startup` :

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* `Microsoft.Extensions.Hosting.IHostEnvironment`
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Contraintes d’injection de `HostBuilder` :

* Autorisez la génération du conteneur DI une seule fois.
* Évite les problèmes de durée de vie des objets résultants, tels que la résolution de plusieurs instances de singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization déplacé vers un autre assembly

Les ASP.NET Core 2,2 et les méthodes `AddAuthorization` inférieures dans *Microsoft. AspNetCore. Authorization. dll*:

* Ont été renommés `AddAuthorizationCore`.
* Ont été déplacés vers *Microsoft. AspNetCore. Authorization. Policy. dll*.

Les applications qui utilisent à la fois *Microsoft. AspNetCore. Authorization. dll* et *Microsoft. AspNetCore. Authorization. Policy. dll* ne sont pas affectées.

Les applications qui n’utilisent pas *Microsoft. AspNetCore. Authorization. Policy. dll* doivent effectuer l’une des opérations suivantes :

* Ajoutez une référence à *Microsoft. AspNetCore. Authorization. Policy. dll*. Cette approche fonctionne pour la plupart des applications et est tout ce qui est nécessaire.
* Passer à l’utilisation de `AddAuthorizationCore`

Pour plus d’informations, consultez [modification avec rupture dans `AddAuthorization(o =>`) surcharges dans un autre assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interface utilisateur d’identité

Mises à jour de l’interface utilisateur des identités pour ASP.NET Core 3,0 :

* Ajoutez une référence de package à [Microsoft. AspNetCore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Les applications qui n’utilisent pas Razor Pages doivent appeler `MapRazorPages`. Consultez [Razor pages](#razor-pages) dans ce document.
* Bootstrap 4 est l’infrastructure d’interface utilisateur par défaut. Définissez une propriété de projet `IdentityUIFrameworkVersion` pour modifier la valeur par défaut. Pour plus d’informations, consultez [cette annonce GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Le client JavaScript SignalR est passé de `@aspnet/signalr` à `@microsoft/signalr`. Pour réagir à cette modification, modifiez les références dans les fichiers *Package. JSON* , les instructions `require` et les instructions ECMAScript `import`.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON est le protocole par défaut

`System.Text.Json` est maintenant le protocole de concentrateur par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, appelez `AddJsonProtocol` pour définir les options du sérialiseur.

**Serveurs**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculer vers Newtonsoft. JSON

Si vous utilisez des fonctionnalités de `Newtonsoft.Json` qui ne sont pas prises en charge dans `System.Text.Json`, vous pouvez revenir à `Newtonsoft.Json` :

1. Installez [Microsoft. AspNetCore.SignalR. Package NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Sur le client, chaînez un appel de méthode `AddNewtonsoftJsonProtocol` à l’instance `HubConnectionBuilder` :

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sur le serveur, chaînez un appel de méthode `AddNewtonsoftJsonProtocol` à l’appel de méthode `AddSignalR` dans `Startup.ConfigureServices` :

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Accepter la compilation au moment de l’exécution

Avant ASP.NET Core 3,0, la compilation du runtime des vues était une fonctionnalité implicite de l’infrastructure. La compilation Runtime complète la compilation des vues au moment de la génération. Il permet à l’infrastructure de compiler des vues et des pages Razor (fichiers *. cshtml* ) quand les fichiers sont modifiés, sans avoir à régénérer l’application entière. Cette fonctionnalité prend en charge le scénario d’apport d’une modification rapide dans l’IDE et d’actualisation du navigateur pour afficher les modifications.

Dans ASP.NET Core 3,0, la compilation du runtime est un scénario d’abonnement. La compilation au moment de la génération est le seul mécanisme pour la compilation de la vue qui est activée par défaut. Le runtime s’appuie sur Visual Studio ou [dotnet-Watch](xref:tutorials/dotnet-watch) dans Visual Studio code pour régénérer le projet lorsqu’il détecte des modifications apportées aux fichiers *. cshtml* . Dans Visual Studio, les modifications apportées aux fichiers *. cs*, *. cshtml*ou *. Razor* dans le projet en cours d’exécution (<kbd>CTRL + F5</kbd>), mais pas débogués (<kbd>F5</kbd>), déclenchent la recompilation du projet.

Pour activer la compilation au moment de l’exécution dans votre projet ASP.NET Core 3,0 :

1. Installer le package NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Mettez à jour `Startup.ConfigureServices` pour appeler `AddRazorRuntimeCompilation` :

    Pour ASP.NET Core MVC, utilisez le code suivant :

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pour ASP.NET Core Razor Pages, utilisez le code suivant :
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
L’exemple à https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation montre un exemple d’activation conditionnelle de la compilation au moment de l’exécution dans les environnements de développement.

Pour plus d’informations sur la compilation de fichiers Razor, consultez <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrer des bibliothèques via le multi-ciblage

Les bibliothèques doivent souvent prendre en charge plusieurs versions de ASP.NET Core. La plupart des bibliothèques qui ont été compilées avec des versions antérieures de ASP.NET Core doivent continuer à fonctionner sans problème. Les conditions suivantes nécessitent la compilation croisée de l’application :

* La bibliothèque s’appuie sur une fonctionnalité qui a une [modification avec rupture](#breaking-api-changes)binaire.
* La bibliothèque veut tirer parti des nouvelles fonctionnalités de ASP.NET Core 3,0. 

Exemple :

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Utilisez `#ifdefs` pour activer ASP.NET Core API spécifiques à 3,0 :

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Publier

Supprimez les dossiers *bin* et *obj* dans le répertoire du projet.

## <a name="testserver"></a>TestServer

Pour les applications qui utilisent <xref:Microsoft.AspNetCore.TestHost.TestServer> directement avec l' [hôte générique](xref:fundamentals/host/web-host), créez le `TestServer` sur un <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> dans <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost*> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interruption des modifications d’API

Examiner les modifications avec rupture :

* [Liste complète des modifications avec rupture dans la version ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interruption des modifications d’API dans anti-contrefaçon, cors, diagnostics, MVC et routage](https://github.com/aspnet/Announcements/issues/387). Cette liste comprend les modifications avec rupture pour les commutateurs de compatibilité.
* Pour obtenir un résumé des modifications avec rupture 2,2 à 3,0 sur .NET Core, ASP.NET Core et Entity Framework Core, consultez [modifications avec rupture pour la migration de la version 2,2 vers 3,0](/dotnet/core/compatibility/2.2-3.0).
* [Certains paramètres par défaut de SameSite de cookie sont devenus None (ASPNET/announcements #348)](https://github.com/aspnet/Announcements/issues/348).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 sur Azure App Service

Pour connaître la progression du déploiement de .NET Core vers Azure App Service, consultez le site Web officiel [.net Core sur app service](https://aspnetcoreon.azurewebsites.net/) . Tant que .NET Core 3,0 n’est pas disponible sur Azure App Service, suivez les instructions de la procédure de [déploiement de la version préliminaire de ASP.net core en Azure App service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
AddAuthorization déplacé vers un autre assembly
