---
title: Migrer de ASP.NET Core 2,2 vers la version préliminaire 3,0
author: tdykstra
description: Découvrez comment migrer un projet ASP.NET Core 2,2 vers ASP.NET Core 3,0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 08/05/2019
uid: migration/22-to-30
ms.openlocfilehash: 6312feb05cc917dd28e40b01f51a5fbf31c59e37
ms.sourcegitcommit: 2eb605f4f20ac4dd9de6c3b3e3453e108a357a21
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/06/2019
ms.locfileid: "68819888"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2,2 à 3,0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2,2 existant vers ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

* Définissez le [moniker du Framework cible (TFM)](/dotnet/standard/frameworks) sur `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Supprimez `<PackageReference>` l’un des sous-packages [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) ou [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Supprimez `<PackageReference>` tout dans le package [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Met à `Version` jour l’attribut `<PackageReference>` sur les `Microsoft.AspNetCore.*` éléments restants pour les packages vers l' `3.0.0-preview5-19227-01`aperçu actuel (par exemple,).

  S’il n’existe aucune version 3,0 d’un package, le package peut avoir été déconseillé dans 3,0. Un grand nombre de ces packages font `Microsoft.AspNetCore.App` partie de et ne doivent pas être référencés individuellement. Pour obtenir une liste préliminaire des packages qui ne sont plus produits dans 3,0, consultez [arrêter la production de packages pour les assemblys de Framework partagé dans 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). L' *infrastructure partagée* est l’ensemble d’assemblys (fichiers *. dll* ) qui sont installés sur l’ordinateur et référencés par `Microsoft.AspNetCore.App`. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les assemblys de plusieurs composants notables ont été `Microsoft.AspNetCore.App` supprimés de dans 3,0. Ajoutez `<PackageReference>` des éléments si vous utilisez des API à partir de packages listés dans des [assemblys en cours de suppression de Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Voici quelques exemples de composants supprimés:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  La liste des assemblys en cours `Microsoft.AspNetCore.App` d’expédition n’a pas été finalisée et sera modifiée avant 3,0 RTM.

  Examinons le code ci-dessous.

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  La `ReadAsAsync` méthode appelée dans le code précédent est incluse dans `Microsoft.AspNet.WebApi.Client`. Installez le package NuGet [Microsoft. Aspnet. WebApi. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) pour résoudre le problème de compilation dans 3,0.

* Ajoutez la [prise en charge de JSON.net](#jsonnet-support).

* Les projets sont par défaut du [modèle d’hébergement in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.net Core 3,0 ou version ultérieure. Vous pouvez éventuellement supprimer la `<AspNetCoreHostingModel>` propriété dans le fichier projet si sa valeur est. `InProcess`

## <a name="jsonnet-support"></a>Support Json.NET

Dans le cadre du travail d' [amélioration du ASP.net Core Framework partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de la ASP.net Core Framework partagé.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0:

* Ajoutez une référence de package à [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Mettez `Startup.ConfigureServices` à jour `AddNewtonsoftJson`pour appeler.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson`est compatible avec les nouvelles méthodes d’inscription de service MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Les paramètres Json.NET peuvent être définis dans l’appel `AddNewtonsoftJson`à:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Inscription du service MVC

ASP.NET Core 3,0 ajoute de nouvelles options pour l’inscription de `Startup.ConfigureServices`scénarios MVC dans.

Trois nouvelles méthodes d’extension de niveau supérieur liées aux scénarios MVC `IServiceCollection` sur sont disponibles. Les modèles utilisent ces nouvelles méthodes à `UseMvc`la place de. Toutefois, `AddMvc` continue à se comporter comme dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas aux vues ou aux pages. Le modèle d’API utilise ce code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge de Razor Pages et de la prise en charge minimale du contrôleur. Le modèle d’application Web utilise ce code:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l' `AddMvc` appel de dans ASP.net Core 2,2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Mettre à jour le code de démarrage du routage

Si une application appelle `UseMvc` ou `UseSignalR`, migrez l’application vers le [routage des points de terminaison](xref:fundamentals/routing) , si possible. Pour améliorer la compatibilité du routage des points de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines des modifications apportées à la génération d’URL introduites dans ASP.NET Core 2,2. Si vous avez rencontré des problèmes lors de l’utilisation du routage de point de terminaison dans 2,2, attendez-vous à des améliorations de ASP.NET Core 3,0, avec les exceptions suivantes:

* Si l’application implémente `IRouter` ou hérite de `Route`, vous souhaiterez peut-être éviter la migration à ce stade. Fournir des commentaires au [plan de la migration des implémentations basées sur IRouter sur le routage des points de terminaison](https://github.com/aspnet/AspNetCore/issues/4221).

* Si l’application accède `RouteData.Routers` directement à MVC, vous souhaiterez peut-être éviter la migration à ce stade. Fournissez des commentaires lors [de la migration pour l’utilisation de RouteData. routeurs](https://github.com/aspnet/AspNetCore/issues/9148).

Le routage des points de terminaison prend en charge les mêmes syntaxe de modèle d' `IRouter`itinéraire et fonctionnalités de création de modèle de routage que. Le routage des `IRouteContraint`points de terminaison prend en charge. Le routage des `[Route]`points `[HttpGet]`de terminaison prend en charge, et les autres attributs de routage Mvc.

Pour la plupart des applications `Startup` , nécessite uniquement des modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup. configure

Conseils généraux:

* Ajoutez `UseRouting`. 
* Si l’application appelle `UseStaticFiles`, placez `UseStaticFiles` -la **avant** `UseRouting`.
* Si l’application utilise des fonctionnalités d’authentification/d' `AuthorizePage` autorisation `[Authorize]`telles que ou, placez `UseAuthentication` l' `UseAuthorization` appel à et **après** `UseRouting` (et **après** `UseCors` l’utilisation de l’intergiciel (middleware) cors).
* Remplacez `UseMvc` ou `UseSignalR` par .`UseEndpoints`
* Si l’application utilise des scénarios [cors](xref:security/cors) , tels `[EnableCors]`que, placez l’appel `UseCors` à avant tout autre intergiciels qui utilise cors (par exemple, `UseCors` placez `UseAuthentication`avant `UseAuthorization`, et `UseMvc`).

Voici un exemple de `Startup.Configure` dans une application ASP.net Core 2,2 standard:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour `Startup.Configure` du code précédent:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Aide sur le middleware de sécurité

La prise en charge de l’autorisation et de CORS est unifiée autour de l’approche de l' [intergiciel (middleware](xref:fundamentals/middleware/index) ). Cela permet d’utiliser les mêmes intergiciels et fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation mis à jour est fourni dans cette version, et l’intergiciel (middleware) CORS est amélioré afin de pouvoir comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. L’intergiciel était fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC devaient être utilisés **sans** l’intergiciel dans d’autres cas d’usage. Avec ASP.NET Core 3,0, nous recommandons que toutes les applications qui requièrent CORS utilisent l’intergiciel (middleware) CORS en tandem avec le routage du point de terminaison. `UseCors`peut être fourni avec une stratégie par défaut, `[EnableCors]` et `[DisableCors]` les attributs et peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire. 

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison `default` avec la stratégie nommée.
* La `MyController` classe désactive cors avec l' `[DisableCors]` attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Dans les versions antérieures de ASP.net Core, la prise en charge de `[Authorize]` l’autorisation a été fournie via l’attribut. L’intergiciel d’autorisation n’est pas disponible. Dans ASP.NET Core 3,0, l’intergiciel (middleware) d’autorisation est requis. Nous vous recommandons de placer le ASP.net Core middleware d'`UseAuthorization`autorisation () `UseAuthentication`immédiatement après. L’intergiciel d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.net Core 3,0 ou version ultérieure `UseAuthorization` , est appelé `Startup.Configure`dans, et les `HomeController` éléments suivants requièrent un utilisateur connecté:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si l’application utilise un `AuthorizeFilter` comme filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie à `UseAuthorization` l’intergiciel (middleware).

Dans l’exemple suivant, une stratégie personnalisée à appliquer à toutes les demandes lorsque `UseAuthorization` est appelé, et le `HomeController` autorise l’accès sans que l’utilisateur se connecte à l’application:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L’autorisation par intergiciel fonctionne sans que l’infrastructure ait une connaissance spécifique de l’autorisation. Par exemple, les [contrôles d’intégrité](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

Dans l’exemple suivant, `UseAuthorization` traite l’autorisation sans une stratégie par défaut, `/healthz` mais le point de terminaison de contrôle d’intégrité requiert `admin` que l’utilisateur soit dans le rôle: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est implémentée pour certains scénarios. `UseEndpoint`l’intergiciel (middleware) lève une exception si une stratégie d’autorisation ou CORS est ignorée en raison d’un intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incompatible est en cours.

### <a name="migrate-signalr"></a>Migrer Signalr

Le mappage des hubs Signalr est désormais effectué `UseEndpoints`à l’intérieur de. 

Mappez chaque concentrateur avec `MapHub`. Comme dans les versions précédentes, chaque concentrateur est explicitement listé.

Dans l’exemple suivant, la prise en `ChatHub` charge du Hub signalr est ajoutée:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Migrer des contrôleurs MVC

Le mappage de contrôleurs a désormais `UseEndpoints`lieu à l’intérieur de. 

Ajoutez `MapControllers` si l’application utilise le routage d’attributs. Dans la mesure où le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3,0 ou version ultérieure, l’ajout de contrôleurs routés par attribut est un abonnement. 

Remplacez ce qui suit:

* `MapRoute`avec`MapControllerRoute`
* `MapAreaRoute`avec`MapAreaControllerRoute`

Étant donné que le routage inclut désormais une prise en charge de plus que MVC, la terminologie a changé pour indiquer clairement ce qu’ils font. Les itinéraires conventionnels `MapControllerRoute` tels que / `MapAreaControllerRoute` / sont appliquésdansl’ordredanslequelilssontajoutés.`MapDefaultControllerRoute` Placez d’abord des itinéraires plus spécifiques (tels que des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers`Ajoute la prise en charge des contrôleurs routés par attribut.
* `MapAreaControllerRoute`Ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute`Ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Migrer Razor Pages

Le mappage de Razor Pages a maintenant `UseEndpoints`lieu à l’intérieur de.

Ajoutez `MapRazorPages` si l’application utilise Razor pages. Dans la mesure où le routage des points de terminaison inclut la prise en charge de nombreuses infrastructures, l’ajout de Razor Pages est désormais un abonnement.

Dans l’exemple suivant, `MapRazorPages` ajoute la prise en charge de Razor pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

L’utilisation de `UseMvc` MVC `UseMvcWithDefaultRoute` via ou dans ASP.net Core 3,0 requiert un abonnement explicite à `Startup.ConfigureServices`l’intérieur de. Cela est nécessaire, car MVC doit savoir s’il peut reposer sur l’autorisation et l’intergiciel CORS pendant l’initialisation. Un analyseur est fourni pour avertir si l’application tente d’utiliser une configuration non prise en charge.

Si l’application nécessite une `IRouter` prise en charge `EnableEndpointRouting` héritée, désactivez l' `Startup.ConfigureServices`une des approches suivantes dans:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Migrer les contrôles d’intégrité

Les contrôles d’intégrité peuvent être utilisés en tant que *routeur* avec routage des points de terminaison.

Ajoutez `MapHealthChecks` pour utiliser les vérifications d’intégrité avec routage du point de terminaison. La `MapHealthChecks` méthode accepte des arguments similaires `UseHealthChecks`à. L’avantage de l' `MapHealthChecks` utilisation `UseHealthChecks` de la valeur on est la possibilité d’appliquer une autorisation et d’avoir un contrôle plus précis de la stratégie de correspondance. 

Dans l’exemple suivant, `MapHealthChecks` est appelé pour un point de terminaison de `/healthz`contrôle d’intégrité sur:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3,0 utilisent l' [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient l' [hôte Web](xref:fundamentals/host/web-host). Le code suivant illustre la classe générée `Program` par le modèle ASP.net Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant illustre la classe ASP.net Core 2,2 générée `Program` par le modèle:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>reste dans 3,0 et est le type de la `webBuilder` vue dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>sera dépréciée dans une version ultérieure et remplacée par `HostBuilder`.

La modification la plus significative `WebHostBuilder` de `HostBuilder` en est l' [injection de dépendances (di)](xref:fundamentals/dependency-injection). Lorsque vous `HostBuilder`utilisez, vous pouvez uniquement <xref:Microsoft.Extensions.Configuration.IConfiguration> injecter `Startup`et <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> dans le constructeur de. Contraintes `HostBuilder` di:

* Autorisez la génération du conteneur DI une seule fois.
* Évite les problèmes de durée de vie des objets résultants, tels que la résolution de plusieurs instances de singletons.

## <a name="update-signalr-code"></a>Mettre à jour le code Signalr

`System.Text.Json`est maintenant le protocole de concentrateur par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, appelez `AddJsonProtocol` pour définir les options du sérialiseur.

**Serveurs**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculer vers Newtonsoft. JSON

Si vous utilisez des fonctionnalités de `Newtonsoft.Json` qui ne sont pas `System.Text.Json`prises en charge dans, vous `Newtonsoft.Json`pouvez revenir à:

1. Installez le package NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Sur le client, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `HubConnectionBuilder` à l’instance:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sur le serveur, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `AddSignalR` à l’appel `Startup.ConfigureServices`de méthode dans:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Accepter la compilation au moment de l’exécution

Dans 3,0, la compilation du runtime est un scénario d’abonnement. Pour activer la compilation au moment https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation de l’exécution, consultez.
