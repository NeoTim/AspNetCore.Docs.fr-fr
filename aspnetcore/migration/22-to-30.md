---
title: Migrer de ASP.NET Core 2,2 vers la version préliminaire 3,0
author: rick-anderson
description: Découvrez comment migrer un projet ASP.NET Core 2,2 vers ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: ce16961c8a30ed4b905d5a20b2230fbde269a3ed
ms.sourcegitcommit: b1e480e1736b0fe0e4d8dce4a4cf5c8e47fc2101
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/19/2019
ms.locfileid: "71108042"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2,2 à 3,0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2,2 existant vers ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

* Définissez le [moniker du Framework cible (TFM)](/dotnet/standard/frameworks) sur `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Supprimez `<PackageReference>` l’un des sous-packages [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) ou [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Supprimez `<PackageReference>` tout dans le package [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Si votre application utilise des [analyseurs d’API](xref:web-api/advanced/analyzers), `<PackageReference>` supprimez tout élément du package [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) . Modifiez votre fichier projet pour utiliser l’analyseur fourni dans le cadre de la kit SDK .NET Core :

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* Met à `Version` jour l’attribut `<PackageReference>` sur les `Microsoft.AspNetCore.*` éléments restants pour les packages vers l' `3.0.0-preview5-19227-01`aperçu actuel (par exemple,).

  S’il n’existe pas de version 3,0 d’un package, le package peut avoir été déconseillé dans 3,0. Un grand nombre de ces packages font `Microsoft.AspNetCore.App` partie de et ne doivent pas être référencés individuellement. Pour obtenir une liste préliminaire des packages qui ne sont plus produits dans 3,0, consultez [arrêter la production de packages pour les assemblys de Framework partagé dans 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). L' *infrastructure partagée* est l’ensemble d’assemblys (fichiers *. dll* ) qui sont installés sur l’ordinateur et référencés par `Microsoft.AspNetCore.App`. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les assemblys de plusieurs composants notables ont été `Microsoft.AspNetCore.App` supprimés de dans 3,0. Ajoutez `<PackageReference>` des éléments si vous utilisez des API à partir de packages listés dans des [assemblys en cours de suppression de Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Voici quelques exemples de composants supprimés :

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  La liste des assemblys en cours `Microsoft.AspNetCore.App` d’expédition n’a pas été finalisée et sera modifiée avant 3,0 RTM.

  Examinons le code ci-dessous.

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  La `ReadAsAsync` méthode appelée dans le code précédent est incluse dans `Microsoft.AspNet.WebApi.Client`. Installez le package NuGet [Microsoft. Aspnet. WebApi. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) pour résoudre le problème de compilation dans 3,0.

* Ajoutez la [prise en charge de JSON.net](#jsonnet-support).

* Les projets sont par défaut du [modèle d’hébergement in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.net Core 3,0 ou version ultérieure. Vous pouvez éventuellement supprimer la `<AspNetCoreHostingModel>` propriété dans le fichier projet si sa valeur est. `InProcess`

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

Migrer la configuration Kestrel vers le générateur d’hôte `ConfigureWebHostDefaults` Web fourni par (*Program.cs*) :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si l’application crée manuellement l’hôte avec `HostBuilder`, appelez `UseKestrel` sur le générateur d’hôte Web `ConfigureWebHostDefaults`dans :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>L’intergiciel de connexion remplace les adaptateurs de connexion

Les adaptateurs de<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>connexion () ont été supprimés de Kestrel. Remplacer les adaptateurs de connexion par un intergiciel de connexion. L’intergiciel de connexion est similaire à l’intergiciel (middleware) HTTP dans le pipeline ASP.NET Core, mais pour les connexions de niveau inférieur. Journalisation HTTPs et connexion :

* Ont été déplacés des adaptateurs de connexion vers l’intergiciel de connexion.
* Ces méthodes d’extension fonctionnent comme dans les versions précédentes de ASP.NET Core. 

Pour plus d’informations, consultez [l’exemple TlsFilterConnectionHandler dans la section ListenOptions. Protocols de l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstractions de transport déplacées et rendues publiques

La couche de transport Kestrel a été exposée en tant qu' `Connections.Abstractions`interface publique dans. Dans le cadre de ces mises à jour :

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`et les types associés ont été supprimés.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>a été déplacé <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> de vers les options de transport.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>a été supprimé <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>de.

Pour plus d’informations, consultez les ressources GitHub suivantes :

* [Abstractions de réseau client/serveur (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implémenter l’abstraction de l’écouteur socle et plat Kestrel en haut (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>En-têtes de la demande Kestrel

Pour les applications qui ciblent des versions antérieures de ASP.NET Core :

* Kestrel ajoute des en-têtes de code de fin en bloc HTTP/1.1 dans la collection d’en-têtes de demande.
* Les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Cela pose des problèmes d’ambiguïté entre les en-têtes et les codes de fin, de sorte que les codes de fin`RequestTrailerExtensions`ont été déplacés vers une nouvelle collection () en 3,0.

Les codes de fin de requête HTTP/2 sont :

* Non disponible dans ASP.NET Core 2,2.
* Disponible dans 3,0 en `RequestTrailerExtensions`tant que.

De nouvelles méthodes d’extension de demande sont présentes pour accéder à ces codes de fin. Comme avec HTTP/1.1, les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Pour la version 3,0, les méthodes `RequestTrailerExtensions` suivantes sont disponibles :

* `GetDeclaredTrailers`Obtient l’en `Trailer` -tête de la demande qui répertorie les codes de fin à attendre après le corps. &ndash;
* `SupportsTrailers`&ndash; Indique si la demande prend en charge la réception des en-têtes de code de fin.
* `CheckTrailersAvailable`&ndash; Vérifie si la demande prend en charge les codes de fin et s’ils sont disponibles pour la lecture. Cette vérification ne suppose pas qu’il y a des codes de fin à lire. Il se peut qu’il n’y ait aucune `true` remorque à lire même si est retourné par cette méthode.
* `GetTrailer`&ndash; Obtient l’en-tête de fin demandé à partir de la réponse. Vérifiez `SupportsTrailers` avant d' `GetTrailer`appeler, ou <xref:System.NotSupportedException> un peut se produire si la requête ne prend pas en charge les en-têtes de fin.

Pour plus d’informations, consultez [put Request queues in a distinct collection (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO désactivé

`AllowSynchronousIO`active ou désactive les API d’e/s synchrones `HttpReqeuest.Body.Read`, `HttpResponse.Body.Write`telles que `Stream.Flush`, et. Ces API sont une source de privation de thread conduisant à des blocages d’application. Dans 3,0, `AllowSynchronousIO` est désactivé par défaut. Pour plus d’informations, consultez [la section e/s synchrone dans l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Outre l’activation `AllowSynchronousIO` des options `ConfigureKestrel`de avec, les e/s synchrones peuvent également être remplacées par demande comme une atténuation temporaire :

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si vous avez des difficultés <xref:System.IO.TextWriter> avec les implémentations ou d’autres flux qui appellent des API synchrones dans <xref:System.IO.Stream.DisposeAsync*> [dispose](/dotnet/standard/garbage-collection/implementing-dispose), appelez plutôt la nouvelle API.

Pour plus d’informations, consultez [[Announcement] AllowSynchronousIO disabled in All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https supprimé

Dans ASP.NET Core 2,1, le contenu de *Microsoft. AspNetCore. Server. Kestrel. https. dll* a été déplacé vers *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Il s’agissait d’une mise à jour `TypeForwardedTo` sans rupture utilisant des attributs. Pour 3,0, l’assembly vide *Microsoft. AspNetCore. Server. Kestrel. https. dll* (et le package NuGet) a été supprimé.

Les bibliothèques référençant [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) doivent mettre à jour les dépendances de ASP.NET Core à 2,1 ou une version ultérieure.

Les applications et les bibliothèques qui ciblent ASP.NET Core 2,1 ou version ultérieure doivent supprimer toutes les références directes au package [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Support Json.NET

Dans le cadre du travail d' [amélioration du ASP.net Core Framework partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de la ASP.net Core Framework partagé. Votre application peut nécessiter cette référence si elle `Newtonsoft.Json`utilise des fonctionnalités spécifiques telles que les JsonPatch ou les convertisseurs ou si elle [met en forme](xref:web-api/advanced/formatting) `Newtonsoft.Json`des types spécifiques.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0 :

* Ajoutez une référence de package à [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Mettez `Startup.ConfigureServices` à jour `AddNewtonsoftJson`pour appeler.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`est compatible avec les nouvelles méthodes d’inscription de service MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Les paramètres Json.NET peuvent être définis dans l’appel `AddNewtonsoftJson`à :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Inscription du service MVC

ASP.NET Core 3,0 ajoute de nouvelles options pour l’inscription de `Startup.ConfigureServices`scénarios MVC dans.

Trois nouvelles méthodes d’extension de niveau supérieur liées aux scénarios MVC `IServiceCollection` sur sont disponibles. Les modèles utilisent ces nouvelles méthodes à `UseMvc`la place de. Toutefois, `AddMvc` continue à se comporter comme dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas aux vues ou aux pages. Le modèle d’API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge de Razor Pages et de la prise en charge minimale du contrôleur. Le modèle d’application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l' `AddMvc` appel de dans ASP.net Core 2,2 :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routage du code de démarrage

Si une application appelle `UseMvc` ou `UseSignalR`, migrez l’application vers le [routage des points de terminaison](xref:fundamentals/routing) , si possible. Pour améliorer la compatibilité du routage des points de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines des modifications apportées à la génération d’URL introduites dans ASP.NET Core 2,2. Si vous avez rencontré des problèmes lors de l’utilisation du routage de point de terminaison dans 2,2, attendez-vous à des améliorations de ASP.NET Core 3,0, avec les exceptions suivantes :

* Si l’application implémente `IRouter` ou hérite de `Route`, vous souhaiterez peut-être éviter la migration à ce stade. Fournir des commentaires au [plan de la migration des implémentations basées sur IRouter sur le routage des points de terminaison](https://github.com/aspnet/AspNetCore/issues/4221).

* Si l’application accède `RouteData.Routers` directement à MVC, vous souhaiterez peut-être éviter la migration à ce stade. Fournissez des commentaires lors [de la migration pour l’utilisation de RouteData. routeurs](https://github.com/aspnet/AspNetCore/issues/9148).

Le routage des points de terminaison prend en charge les mêmes syntaxe de modèle d' `IRouter`itinéraire et fonctionnalités de création de modèle de routage que. Le routage des `IRouteConstraint`points de terminaison prend en charge. Le routage des `[Route]`points `[HttpGet]`de terminaison prend en charge, et les autres attributs de routage Mvc.

Pour la plupart des applications `Startup` , nécessite uniquement des modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup. configure

Conseils généraux :

* Ajoutez `UseRouting`.
* Si l’application appelle `UseStaticFiles`, placez `UseStaticFiles` -la **avant** `UseRouting`.
* Si l’application utilise des fonctionnalités d’authentification/d' `AuthorizePage` autorisation `[Authorize]`telles que ou, placez `UseAuthentication` l' `UseAuthorization` appel à et **après** `UseRouting` (et **après** `UseCors` l’utilisation de l’intergiciel (middleware) cors).
* Remplacez `UseMvc` ou `UseSignalR` par .`UseEndpoints`
* Si l’application utilise des scénarios [cors](xref:security/cors) , tels `[EnableCors]`que, placez l’appel `UseCors` à avant tout autre intergiciel qui utilise cors (par exemple, placez `UseCors` avant `UseAuthentication`, `UseAuthorization`et `UseEndpoints`).
* Remplacez `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> par `IWebHostEnvironment` et ajoutez une instruction pour l’espace de noms.
* Remplacez `IApplicationLifetime` par <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).
* Remplacez `EnvironmentName` par <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).

Voici un exemple de `Startup.Configure` dans une application ASP.net Core 2,2 standard :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour `Startup.Configure` du code précédent :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité utilisent le routage de point de terminaison avec l’hôte générique. Dans `Startup.Configure`, appelez `MapHealthChecks` sur le générateur de points de terminaison avec l’URL de point de terminaison ou le chemin d’accès relatif :

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Les points de terminaison de contrôle d’intégrité peuvent :

* Spécifiez un ou plusieurs hôtes/ports autorisés.
* Exiger une autorisation.
* Exiger CORS.

Pour plus d'informations, consultez <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Aide sur le middleware de sécurité

La prise en charge de l’autorisation et de CORS est unifiée autour de l’approche de l' [intergiciel (middleware](xref:fundamentals/middleware/index) ). Cela permet d’utiliser les mêmes intergiciels et fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation mis à jour est fourni dans cette version, et l’intergiciel (middleware) CORS est amélioré afin de pouvoir comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. L’intergiciel était fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC devaient être utilisés **sans** l’intergiciel dans d’autres cas d’usage. Avec ASP.NET Core 3,0, nous recommandons que toutes les applications qui requièrent CORS utilisent l’intergiciel (middleware) CORS en tandem avec le routage du point de terminaison. `UseCors`peut être fourni avec une stratégie par défaut, `[EnableCors]` et `[DisableCors]` les attributs et peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire.

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison `default` avec la stratégie nommée.
* La `MyController` classe désactive cors avec l' `[DisableCors]` attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Dans les versions antérieures de ASP.net Core, la prise en charge de `[Authorize]` l’autorisation a été fournie via l’attribut. L’intergiciel d’autorisation n’est pas disponible. Dans ASP.NET Core 3,0, l’intergiciel (middleware) d’autorisation est requis. Nous vous recommandons de placer le ASP.net Core middleware d'`UseAuthorization`autorisation () `UseAuthentication`immédiatement après. L’intergiciel d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.net Core 3,0 ou version ultérieure `UseAuthorization` , est appelé `Startup.Configure`dans, et les `HomeController` éléments suivants requièrent un utilisateur connecté :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si l’application utilise un `AuthorizeFilter` comme filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie dans l’appel `AddAuthorization`à.

Le `DefaultPolicy` est initialement configuré pour exiger une authentification, de sorte qu’aucune configuration supplémentaire n’est requise. Dans l’exemple suivant, les points de terminaison MVC sont `RequireAuthorization` marqués comme afin que toutes les requêtes doivent être autorisées `DefaultPolicy`en fonction du. Toutefois, le `HomeController` autorise l’accès sans que l’utilisateur se `[AllowAnonymous]`connecte à l’application en raison des éléments suivants :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Les stratégies peuvent également être personnalisées. En s’appuyant sur l’exemple `DefaultPolicy` précédent, le est configuré pour exiger une authentification et une étendue spécifique :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Sinon, tous les points de terminaison peuvent être configurés pour exiger `[Authorize]` l' `RequireAuthorization` autorisation sans ou en `FallbackPolicy`configurant un. `FallbackPolicy` Est différent `DefaultPolicy`de. Est déclenché par `[Authorize]` `FallbackPolicy` ou `RequireAuthorization`, tandis que est déclenché quand aucune autre stratégie n’est définie. `DefaultPolicy` `FallbackPolicy`est initialement configuré pour autoriser les demandes sans autorisation.

L’exemple suivant est identique à l’exemple précédent `DefaultPolicy` , mais `FallbackPolicy` utilise pour toujours exiger l’authentification sur tous les points de terminaison `[AllowAnonymous]` sauf si est spécifié :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L’autorisation par intergiciel fonctionne sans que l’infrastructure ait une connaissance spécifique de l’autorisation. Par exemple, les [contrôles d’intégrité](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

En outre, chaque point de terminaison peut personnaliser ses exigences d’autorisation. Dans l’exemple suivant, `UseAuthorization` traite l’autorisation `DefaultPolicy`avec, mais le `/healthz` point de terminaison de contrôle `admin` d’intégrité requiert un utilisateur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est implémentée pour certains scénarios. `UseEndpoint`l’intergiciel (middleware) lève une exception si une stratégie d’autorisation ou CORS est ignorée en raison d’un intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incompatible est en cours.

### <a name="signalr"></a>SignalR

Le mappage des hubs Signalr est désormais effectué `UseEndpoints`à l’intérieur de.

Mappez chaque concentrateur avec `MapHub`. Comme dans les versions précédentes, chaque concentrateur est explicitement listé.

Dans l’exemple suivant, la prise en `ChatHub` charge du Hub signalr est ajoutée :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Une nouvelle option permet de contrôler les limites de taille des messages des clients. Par exemple, dans `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Dans ASP.net Core 2,2, vous pouviez définir la `TransportMaxBufferSize` valeur et pour contrôler la taille de message maximale. Dans ASP.NET Core 3,0, cette option contrôle désormais uniquement la taille maximale avant que la contre-pression soit observée.

### <a name="mvc-controllers"></a>Contrôleurs MVC

Le mappage de contrôleurs a désormais `UseEndpoints`lieu à l’intérieur de.

Ajoutez `MapControllers` si l’application utilise le routage d’attributs. Dans la mesure où le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3,0 ou version ultérieure, l’ajout de contrôleurs routés par attribut est un abonnement.

Remplacez ce qui suit :

* `MapRoute`avec`MapControllerRoute`
* `MapAreaRoute`avec`MapAreaControllerRoute`

Étant donné que le routage inclut désormais une prise en charge de plus que MVC, la terminologie a changé pour indiquer clairement ce qu’ils font. Les itinéraires conventionnels `MapControllerRoute` tels que / `MapAreaControllerRoute` / sont appliquésdansl’ordredanslequelilssontajoutés.`MapDefaultControllerRoute` Placez d’abord des itinéraires plus spécifiques (tels que des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers`Ajoute la prise en charge des contrôleurs routés par attribut.
* `MapAreaControllerRoute`Ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute`Ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Pages Razor

Le mappage de Razor Pages a maintenant `UseEndpoints`lieu à l’intérieur de.

Ajoutez `MapRazorPages` si l’application utilise Razor pages. Dans la mesure où le routage des points de terminaison inclut la prise en charge de nombreuses infrastructures, l’ajout de Razor Pages est désormais un abonnement.

Dans l’exemple suivant, `MapRazorPages` ajoute la prise en charge de Razor pages :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

L’utilisation de `UseMvc` MVC `UseMvcWithDefaultRoute` via ou dans ASP.net Core 3,0 requiert un abonnement explicite à `Startup.ConfigureServices`l’intérieur de. Cela est nécessaire, car MVC doit savoir s’il peut reposer sur l’autorisation et l’intergiciel CORS pendant l’initialisation. Un analyseur est fourni pour avertir si l’application tente d’utiliser une configuration non prise en charge.

Si l’application nécessite une `IRouter` prise en charge `EnableEndpointRouting` héritée, désactivez l' `Startup.ConfigureServices`une des approches suivantes dans :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité peuvent être utilisés en tant que *routeur* avec routage des points de terminaison.

Ajoutez `MapHealthChecks` pour utiliser les vérifications d’intégrité avec routage du point de terminaison. La `MapHealthChecks` méthode accepte des arguments similaires `UseHealthChecks`à. L’avantage de l' `MapHealthChecks` utilisation `UseHealthChecks` de la valeur on est la possibilité d’appliquer une autorisation et d’avoir un contrôle plus précis de la stratégie de correspondance.

Dans l’exemple suivant, `MapHealthChecks` est appelé pour un point de terminaison de `/healthz`contrôle d’intégrité sur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3,0 utilisent l' [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient l' [hôte Web](xref:fundamentals/host/web-host). Le code suivant illustre la classe générée `Program` par le modèle ASP.net Core 3,0 :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant illustre la classe ASP.net Core 2,2 générée `Program` par le modèle :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>reste dans 3,0 et est le type de la `webBuilder` vue dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>sera dépréciée dans une version ultérieure et remplacée par `HostBuilder`.

La modification la plus significative `WebHostBuilder` de `HostBuilder` en est l' [injection de dépendances (di)](xref:fundamentals/dependency-injection). Lorsque vous `HostBuilder`utilisez, vous pouvez uniquement <xref:Microsoft.Extensions.Configuration.IConfiguration> injecter `Startup`et <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> dans le constructeur de. Contraintes `HostBuilder` di :

* Autorisez la génération du conteneur DI une seule fois.
* Évite les problèmes de durée de vie des objets résultants, tels que la résolution de plusieurs instances de singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization déplacé vers un autre assembly

Les méthodes ASP.net Core 2,2 et `AddAuthorization` Lower dans *Microsoft. AspNetCore. Authorization. dll*:

* Ont été renommés `AddAuthorizationCore`.
* Ont été déplacés vers *Microsoft. AspNetCore. Authorization. Policy. dll*.

Les applications qui utilisent à la fois *Microsoft. AspNetCore. Authorization. dll* et *Microsoft. AspNetCore. Authorization. Policy. dll* ne sont pas affectées.

Les applications qui n’utilisent pas *Microsoft. AspNetCore. Authorization. Policy. dll* doivent effectuer l’une des opérations suivantes :

* Basculer vers using`AddAuthorizationCore`
* Ajoutez une référence à *Microsoft. AspNetCore. Authorization. Policy. dll*.

Pour plus d’informations, consultez [modification avec `AddAuthorization(o =>`rupture dans) dans un assembly différent #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Code signalr

Le client JavaScript signalr est passé de `@aspnet/signalr` à `@microsoft/signalr`. Pour réagir à cette modification, modifiez les références dans les fichiers *Package. JSON* , les instructions require et les instructions Import ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON est le protocole par défaut

`System.Text.Json`est maintenant le protocole de concentrateur par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, appelez `AddJsonProtocol` pour définir les options du sérialiseur.

**Serveurs**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculer vers Newtonsoft. JSON

Si vous utilisez des fonctionnalités de `Newtonsoft.Json` qui ne sont pas `System.Text.Json`prises en charge dans, vous `Newtonsoft.Json`pouvez revenir à :

1. Installez le package NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Sur le client, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `HubConnectionBuilder` à l’instance :

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sur le serveur, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `AddSignalR` à l’appel `Startup.ConfigureServices`de méthode dans :

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Accepter la compilation au moment de l’exécution

Dans 3,0, la compilation du runtime est un scénario d’abonnement. Pour activer la compilation au moment <xref:mvc/views/view-compilation#runtime-compilation>de l’exécution, consultez.
