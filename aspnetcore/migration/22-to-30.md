---
title: Migrer de ASP.NET Core 2,2 à 3,0
author: rick-anderson
description: Découvrez comment migrer un projet ASP.NET Core 2,2 vers ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/29/2019
uid: migration/22-to-30
ms.openlocfilehash: ae725fef58666f851bb11fec3b869d3a47b57900
ms.sourcegitcommit: dc96d76f6b231de59586fcbb989a7fb5106d26a8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/01/2019
ms.locfileid: "71703788"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2,2 à 3,0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2,2 existant vers ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

### <a name="update-the-target-framework"></a>Mettre à jour la version cible de .NET Framework

ASP.NET Core 3,0 et versions ultérieures s’exécutent uniquement sur .NET Core. Définissez le [moniker du Framework cible (TFM)](/dotnet/standard/frameworks) sur `netcoreapp3.0`:

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Supprimer les références de package obsolètes

ASP.NET Core ne produit plus un grand nombre de fonctionnalités de packages NuGet. Ces références de package doivent être supprimées de votre fichier projet. Pour afficher la liste complète des packages qui ne sont plus produits, voir ci-dessous :

<details>
    <summary>Cliquez ici pour développer la liste des packages qui ne sont plus produits</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. en-têtes</li>
    </ul>
</details>

### <a name="framework-reference"></a>Référence du Framework

Les fonctionnalités de ASP.net core qui étaient disponibles via l’un des packages répertoriés ci-dessus sont disponibles `Microsoft.AspNetCore.App` dans le cadre de l’infrastructure partagée. L' *infrastructure partagée* est l’ensemble d’assemblys (fichiers *. dll* ) qui sont installés sur l’ordinateur et qui comprend un composant d’exécution et un pack de ciblage. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les projets qui ciblent le `Microsoft.NET.Sdk.Web` Kit de développement logiciel (SDK) référencent implicitement le `Microsoft.AspNetCore.App` Framework.

Aucune référence supplémentaire n’est requise pour ces projets :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Les projets qui `Microsoft.NET.Sdk` ciblent ou `Microsoft.NET.Sdk.Razor` le kit de développement `FrameworkReference` logiciel `Microsoft.AspNetCore.App`(SDK) doivent ajouter un explicite à :

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Builds dépendantes du Framework utilisant l’ancrage

Les builds dépendantes du Framework des applications console qui utilisent un package qui dépend de l' [infrastructure partagée](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.net Core peuvent fournir l’erreur d’exécution suivante :

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`est le Framework partagé contenant le runtime ASP.NET Core et est uniquement présent sur l’image de l’ancrage [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  Le kit de développement logiciel (SDK) 3,0 réduit la taille des builds dépendantes de l’infrastructure à l’aide de asp.net core en n’incluant pas de copies en double des bibliothèques disponibles dans le Framework partagé.  Il s’agit d’une économie potentielle allant jusqu’à ~ 18MB, mais elle nécessite que le runtime ASP.NET Core soit présent/installé pour exécuter l’application.

Pour déterminer si l’application a une dépendance (directe ou indirecte) sur le ASP.NET Core Framework partagé, examinez le fichier *runtimeconfig. JSON* généré pendant une génération/publication de votre application. Le fichier JSON suivant illustre une dépendance sur le ASP.NET Core Framework partagé :

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si votre application utilise la station d’accueil, utilisez une image de base qui comprend ASP.NET Core 3,0. Par exemple, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Ajouter des références de package pour les assemblys supprimés

ASP.net Core 3,0 supprime certains assemblys qui faisaient auparavant partie de la `Microsoft.AspNetCore.App` référence du package. Pour continuer à utiliser les fonctionnalités fournies par ces assemblys, référencez les versions 3,0 des packages correspondants :

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Pour plus d’informations sur le référencement du package spécifique au fournisseur de base de données, consultez [fournisseurs de bases de données](/ef/core/providers/index).

* Interface utilisateur d’identité

  La prise en charge de l' [interface utilisateur d’identité](xref:security/authentication/identity) peut être ajoutée en référençant le package [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Services SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* La &ndash; prise en charge de l’authentification pour les flux d’authentification tiers est disponible sous forme de packages NuGet :

  * OAuth Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Jeton du porteur OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Authentification de compte Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Authentification OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Authentification WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* La prise en charge de la mise `System.Net.HttpClient` en forme et de la négociation du contenu pour &ndash; le package NuGet [Microsoft. Aspnet. WebApi. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) offre une extensibilité `System.Net.HttpClient` utile avec les API telles que `ReadAsAsync`, `PostJsonAsync` etc.

* La prise en &ndash; charge de la compilation du runtime Razor pour la compilation du runtime des vues et des pages Razor fait désormais partie de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* La prise en charge de MVC `Newtonsoft.Json` pour l’utilisation de MVC avec `Newtonsoft.Json` est désormais intégrée à [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson). &ndash;

### <a name="analyzer-support"></a>Prise en charge de l’analyseur

Les projets qui `Microsoft.NET.Sdk.Web` ciblent implicitement des analyseurs de référence ont été fournis précédemment dans le cadre du package [Microsoft. AspNetCore. Mvc. Analysis](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Aucune référence supplémentaire n’est requise pour les activer.

Si votre application utilise des [analyseurs d’API](xref:web-api/advanced/analyzers) livrés précédemment à l’aide du package [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , modifiez votre fichier projet pour référencer les analyseurs fournis dans le cadre du kit de développement logiciel (SDK) Web .net Core :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Bibliothèque de classes Razor

Les projets de bibliothèque de classes Razor qui fournissent des composants d’interface `AddRazorSupportForMvc` utilisateur pour MVC doivent définir la propriété dans le fichier projet :

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modèle d’hébergement in-process

Les projets sont par défaut du [modèle d’hébergement in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.net Core 3,0 ou version ultérieure. Vous pouvez éventuellement supprimer la `<AspNetCoreHostingModel>` propriété dans le fichier projet si sa valeur est. `InProcess`

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

Migrer la configuration Kestrel vers le générateur d’hôte `ConfigureWebHostDefaults` Web fourni par (*Program.cs*) :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si l’application crée manuellement l’hôte avec `HostBuilder`, appelez `UseKestrel` sur le générateur d’hôte Web `ConfigureWebHostDefaults`dans :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>L’intergiciel de connexion remplace les adaptateurs de connexion

Les adaptateurs de<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>connexion () ont été supprimés de Kestrel. Remplacer les adaptateurs de connexion par un intergiciel de connexion. L’intergiciel de connexion est similaire à l’intergiciel (middleware) HTTP dans le pipeline ASP.NET Core, mais pour les connexions de niveau inférieur. Journalisation HTTPs et connexion :

* Ont été déplacés des adaptateurs de connexion vers l’intergiciel de connexion.
* Ces méthodes d’extension fonctionnent comme dans les versions précédentes de ASP.NET Core. 

Pour plus d’informations, consultez [l’exemple TlsFilterConnectionHandler dans la section ListenOptions. Protocols de l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstractions de transport déplacées et rendues publiques

La couche de transport Kestrel a été exposée en tant qu' `Connections.Abstractions`interface publique dans. Dans le cadre de ces mises à jour :

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`et les types associés ont été supprimés.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>a été déplacé <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> de vers les options de transport.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>a été supprimé <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>de.

Pour plus d’informations, consultez les ressources GitHub suivantes :

* [Abstractions de réseau client/serveur (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implémenter l’abstraction de l’écouteur socle et plat Kestrel en haut (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>En-têtes de la demande Kestrel

Pour les applications qui ciblent des versions antérieures de ASP.NET Core :

* Kestrel ajoute des en-têtes de code de fin en bloc HTTP/1.1 dans la collection d’en-têtes de demande.
* Les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Cela pose des problèmes d’ambiguïté entre les en-têtes et les codes de fin, de sorte que les codes de fin`RequestTrailerExtensions`ont été déplacés vers une nouvelle collection () en 3,0.

Les codes de fin de requête HTTP/2 sont :

* Non disponible dans ASP.NET Core 2,2.
* Disponible dans 3,0 en `RequestTrailerExtensions`tant que.

De nouvelles méthodes d’extension de demande sont présentes pour accéder à ces codes de fin. Comme avec HTTP/1.1, les codes de fin sont disponibles une fois que le corps de la demande est lu jusqu’à la fin.

Pour la version 3,0, les méthodes `RequestTrailerExtensions` suivantes sont disponibles :

* `GetDeclaredTrailers`Obtient l’en `Trailer` -tête de la demande qui répertorie les codes de fin à attendre après le corps. &ndash;
* `SupportsTrailers`&ndash; Indique si la demande prend en charge la réception des en-têtes de code de fin.
* `CheckTrailersAvailable`&ndash; Vérifie si la demande prend en charge les codes de fin et s’ils sont disponibles pour la lecture. Cette vérification ne suppose pas qu’il y a des codes de fin à lire. Il se peut qu’il n’y ait aucune `true` remorque à lire même si est retourné par cette méthode.
* `GetTrailer`&ndash; Obtient l’en-tête de fin demandé à partir de la réponse. Vérifiez `SupportsTrailers` avant d' `GetTrailer`appeler, ou <xref:System.NotSupportedException> un peut se produire si la requête ne prend pas en charge les en-têtes de fin.

Pour plus d’informations, consultez [put Request queues in a distinct collection (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO désactivé

`AllowSynchronousIO`active ou désactive les API d’e/s synchrones `HttpRequest.Body.Read`, `HttpResponse.Body.Write`telles que `Stream.Flush`, et. Ces API sont une source de privation de thread conduisant à des blocages d’application. Dans 3,0, `AllowSynchronousIO` est désactivé par défaut. Pour plus d’informations, consultez [la section e/s synchrone dans l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Outre l’activation `AllowSynchronousIO` des options `ConfigureKestrel`de avec, les e/s synchrones peuvent également être remplacées par demande comme une atténuation temporaire :

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si vous avez des difficultés <xref:System.IO.TextWriter> avec les implémentations ou d’autres flux qui appellent des API synchrones dans <xref:System.IO.Stream.DisposeAsync*> [dispose](/dotnet/standard/garbage-collection/implementing-dispose), appelez plutôt la nouvelle API.

Pour plus d’informations, consultez [[Announcement] AllowSynchronousIO disabled in All Servers (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https supprimé

Dans ASP.NET Core 2,1, le contenu de *Microsoft. AspNetCore. Server. Kestrel. https. dll* a été déplacé vers *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Il s’agissait d’une mise à jour `TypeForwardedTo` sans rupture utilisant des attributs. Pour 3,0, l’assembly vide *Microsoft. AspNetCore. Server. Kestrel. https. dll* (et le package NuGet) a été supprimé.

Les bibliothèques référençant [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) doivent mettre à jour les dépendances de ASP.NET Core à 2,1 ou une version ultérieure.

Les applications et les bibliothèques qui ciblent ASP.NET Core 2,1 ou version ultérieure doivent supprimer toutes les références directes au package [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Support Json.NET

Dans le cadre du travail d' [amélioration du ASP.net Core Framework partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de la ASP.net Core Framework partagé.

La valeur par défaut pour ASP.NET Core est désormais [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), qui est une nouveauté de .net Core 3,0. Envisagez d’utiliser dans `System.Text.Json` la mesure du possible. Elle est très performante et ne nécessite pas de dépendance de bibliothèque supplémentaire. Toutefois, étant `System.Text.Json` donné que est nouveau, il est possible qu’il manque actuellement des fonctionnalités dont votre application a besoin.

`Newtonsoft.Json` Votre application peut nécessiter une intégration si elle utilise `Newtonsoft.Json`des fonctionnalités spécifiques telles que les JsonPatch ou les convertisseurs ou si elle [met en forme](xref:web-api/advanced/formatting) `Newtonsoft.Json`des types spécifiques.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0 Signalr, consultez [basculer vers Newtonsoft. JSON](#switch-to-newtonsoftjson) dans ce document.

Pour utiliser Json.NET dans un projet ASP.NET Core 3,0 :

* Ajoutez une référence de package à [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Mettez `Startup.ConfigureServices` à jour `AddNewtonsoftJson`pour appeler.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`est compatible avec les nouvelles méthodes d’inscription de service MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Les paramètres Json.NET peuvent être définis dans l’appel `AddNewtonsoftJson`à :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Inscription du service MVC

ASP.NET Core 3,0 ajoute de nouvelles options pour l’inscription de `Startup.ConfigureServices`scénarios MVC dans.

Trois nouvelles méthodes d’extension de niveau supérieur liées aux scénarios MVC `IServiceCollection` sur sont disponibles. Les modèles utilisent ces nouvelles méthodes à `UseMvc`la place de. Toutefois, `AddMvc` continue à se comporter comme dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas aux vues ou aux pages. Le modèle d’API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge de Razor Pages et de la prise en charge minimale du contrôleur. Le modèle d’application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l' `AddMvc` appel de dans ASP.net Core 2,2 :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routage du code de démarrage

Si une application appelle `UseMvc` ou `UseSignalR`, migrez l’application vers le [routage des points de terminaison](xref:fundamentals/routing) , si possible. Pour améliorer la compatibilité du routage des points de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines des modifications apportées à la génération d’URL introduites dans ASP.NET Core 2,2. Si vous avez rencontré des problèmes lors de l’utilisation du routage de point de terminaison dans 2,2, attendez-vous à des améliorations de ASP.NET Core 3,0, avec les exceptions suivantes :

* Si l’application implémente `IRouter` ou hérite de `Route`, utilisez [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) comme remplacement.

* Si l’application accède `RouteData.Routers` directement à MVC pour analyser des URL, vous pouvez la remplacer par l’utilisation de. `LinkParser.ParsePathByEndpointName` 
 * Définissez l’itinéraire avec un nom d’itinéraire.
 * Utilisez `LinkParser.ParsePathByEndpointName` et transmettez le nom de l’itinéraire souhaité.

Le routage des points de terminaison prend en charge les mêmes syntaxe de modèle d' `IRouter`itinéraire et fonctionnalités de création de modèle de routage que. Le routage des `IRouteConstraint`points de terminaison prend en charge. Le routage des `[Route]`points `[HttpGet]`de terminaison prend en charge, et les autres attributs de routage Mvc.

Pour la plupart des applications `Startup` , nécessite uniquement des modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup. configure

Conseils généraux :

* Ajoutez `UseRouting`.
* Si l’application appelle `UseStaticFiles`, placez `UseStaticFiles` -la **avant** `UseRouting`.
* Si l’application utilise des fonctionnalités d’authentification/d' `AuthorizePage` autorisation `[Authorize]`telles que ou, placez `UseAuthentication` l' `UseAuthorization`appel à et `UseRouting` : `UseCors` **après**, et `UseEndpoints`, mais avant :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    }
  ```

* Remplacez `UseMvc` ou `UseSignalR` par .`UseEndpoints`
* Si l’application utilise des scénarios [cors](xref:security/cors) , tels `[EnableCors]`que, placez l’appel `UseCors` à avant tout autre intergiciel qui utilise cors (par exemple, placez `UseCors` avant `UseAuthentication`, `UseAuthorization`et `UseEndpoints`).
* Remplacez `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> par `IWebHostEnvironment` et ajoutez une instruction pour l’espace de noms.
* Remplacez `IApplicationLifetime` par <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).
* Remplacez `EnvironmentName` par <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espace de noms).

Le code suivant est un exemple de `Startup.Configure` dans une application ASP.net Core 2,2 standard :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour `Startup.Configure` du code précédent :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pour la plupart des applications, `UseAuthentication`les `UseAuthorization`appels à `UseCors` , et doivent apparaître entre les `UseRouting` appels `UseEndpoints` à et pour être effectifs.

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité utilisent le routage de point de terminaison avec l’hôte générique. Dans `Startup.Configure`, appelez `MapHealthChecks` sur le générateur de points de terminaison avec l’URL de point de terminaison ou le chemin d’accès relatif :

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Les points de terminaison de contrôle d’intégrité peuvent :

* Spécifiez un ou plusieurs hôtes/ports autorisés.
* Exiger une autorisation.
* Exiger CORS.

Pour plus d'informations, consultez <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Aide sur le middleware de sécurité

La prise en charge de l’autorisation et de CORS est unifiée autour de l’approche de l' [intergiciel (middleware](xref:fundamentals/middleware/index) ). Cela permet d’utiliser les mêmes intergiciels et fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation mis à jour est fourni dans cette version, et l’intergiciel (middleware) CORS est amélioré afin de pouvoir comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. L’intergiciel était fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC devaient être utilisés **sans** l’intergiciel dans d’autres cas d’usage. Avec ASP.NET Core 3,0, nous recommandons que toutes les applications qui requièrent CORS utilisent l’intergiciel (middleware) CORS en tandem avec le routage du point de terminaison. `UseCors`peut être fourni avec une stratégie par défaut, `[EnableCors]` et `[DisableCors]` les attributs et peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire.

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison `default` avec la stratégie nommée.
* La `MyController` classe désactive cors avec l' `[DisableCors]` attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Dans les versions antérieures de ASP.net Core, la prise en charge de `[Authorize]` l’autorisation a été fournie via l’attribut. L’intergiciel d’autorisation n’est pas disponible. Dans ASP.NET Core 3,0, l’intergiciel (middleware) d’autorisation est requis. Nous vous recommandons de placer le ASP.net Core middleware d'`UseAuthorization`autorisation () `UseAuthentication`immédiatement après. L’intergiciel d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.net Core 3,0 ou version ultérieure `UseAuthorization` , est appelé `Startup.Configure`dans, et les `HomeController` éléments suivants requièrent un utilisateur connecté :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si l’application utilise un `AuthorizeFilter` comme filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie dans l’appel `AddAuthorization`à.

Le `DefaultPolicy` est initialement configuré pour exiger une authentification, de sorte qu’aucune configuration supplémentaire n’est requise. Dans l’exemple suivant, les points de terminaison MVC sont `RequireAuthorization` marqués comme afin que toutes les requêtes doivent être autorisées `DefaultPolicy`en fonction du. Toutefois, le `HomeController` autorise l’accès sans que l’utilisateur se `[AllowAnonymous]`connecte à l’application en raison des éléments suivants :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Les stratégies peuvent également être personnalisées. En s’appuyant sur l’exemple `DefaultPolicy` précédent, le est configuré pour exiger une authentification et une étendue spécifique :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Sinon, tous les points de terminaison peuvent être configurés pour exiger `[Authorize]` l' `RequireAuthorization` autorisation sans ou en `FallbackPolicy`configurant un. `FallbackPolicy` Est différent `DefaultPolicy`de. Est déclenché par `[Authorize]` `FallbackPolicy` ou `RequireAuthorization`, tandis que est déclenché quand aucune autre stratégie n’est définie. `DefaultPolicy` `FallbackPolicy`est initialement configuré pour autoriser les demandes sans autorisation.

L’exemple suivant est identique à l’exemple précédent `DefaultPolicy` , mais `FallbackPolicy` utilise pour toujours exiger l’authentification sur tous les points de terminaison `[AllowAnonymous]` sauf si est spécifié :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L’autorisation par intergiciel fonctionne sans que l’infrastructure ait une connaissance spécifique de l’autorisation. Par exemple, les [contrôles d’intégrité](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

En outre, chaque point de terminaison peut personnaliser ses exigences d’autorisation. Dans l’exemple suivant, `UseAuthorization` traite l’autorisation `DefaultPolicy`avec, mais le `/healthz` point de terminaison de contrôle `admin` d’intégrité requiert un utilisateur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est implémentée pour certains scénarios. `UseEndpoint`l’intergiciel (middleware) lève une exception si une stratégie d’autorisation ou CORS est ignorée en raison d’un intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incompatible est en cours.

### <a name="signalr"></a>SignalR

Le mappage des hubs Signalr est désormais effectué `UseEndpoints`à l’intérieur de.

Mappez chaque concentrateur avec `MapHub`. Comme dans les versions précédentes, chaque concentrateur est explicitement listé.

Dans l’exemple suivant, la prise en `ChatHub` charge du Hub signalr est ajoutée :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Une nouvelle option permet de contrôler les limites de taille des messages des clients. Par exemple, dans `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Dans ASP.net Core 2,2, vous pouviez définir la `TransportMaxBufferSize` valeur et pour contrôler la taille de message maximale. Dans ASP.NET Core 3,0, cette option contrôle désormais uniquement la taille maximale avant que la contre-pression soit observée.

### <a name="mvc-controllers"></a>Contrôleurs MVC

Le mappage de contrôleurs a désormais `UseEndpoints`lieu à l’intérieur de.

Ajoutez `MapControllers` si l’application utilise le routage d’attributs. Dans la mesure où le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3,0 ou version ultérieure, l’ajout de contrôleurs routés par attribut est un abonnement.

Remplacez ce qui suit :

* `MapRoute`avec`MapControllerRoute`
* `MapAreaRoute`avec`MapAreaControllerRoute`

Étant donné que le routage inclut désormais une prise en charge de plus que MVC, la terminologie a changé pour indiquer clairement ce qu’ils font. Les itinéraires conventionnels `MapControllerRoute` tels que / `MapAreaControllerRoute` / sont appliquésdansl’ordredanslequelilssontajoutés.`MapDefaultControllerRoute` Placez d’abord des itinéraires plus spécifiques (tels que des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers`Ajoute la prise en charge des contrôleurs routés par attribut.
* `MapAreaControllerRoute`Ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute`Ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Suppression du suffixe Async des noms d’action du contrôleur

Dans ASP.NET Core 3,0, ASP.NET Core MVC supprime le suffixe `Async` des noms d’action du contrôleur. Le routage et la génération de liens sont affectés par cette nouvelle valeur par défaut. Exemple :

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Avant ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/ListAsync* .
* Génération de lien requise spécifiant le suffixe `Async`. Exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

Dans ASP.NET Core 3,0 :

* L’action précédente est accessible à l’itinéraire *Products/List* .
* La génération de liens ne nécessite pas la spécification du suffixe `Async`. Exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Cette modification n’affecte pas les noms spécifiés à l’aide de l’attribut [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Le comportement par défaut peut être désactivé avec le code suivant dans `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Pages Razor

Le mappage de Razor Pages a maintenant `UseEndpoints`lieu à l’intérieur de.

Ajoutez `MapRazorPages` si l’application utilise Razor pages. Dans la mesure où le routage des points de terminaison inclut la prise en charge de nombreuses infrastructures, l’ajout de Razor Pages est désormais un abonnement.

Dans la méthode `Startup.Configure` suivante, `MapRazorPages` ajoute la prise en charge de Razor pages :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

L’utilisation de `UseMvc` MVC `UseMvcWithDefaultRoute` via ou dans ASP.net Core 3,0 requiert un abonnement explicite à `Startup.ConfigureServices`l’intérieur de. Cela est nécessaire, car MVC doit savoir s’il peut reposer sur l’autorisation et l’intergiciel CORS pendant l’initialisation. Un analyseur est fourni pour avertir si l’application tente d’utiliser une configuration non prise en charge.

Si l’application nécessite une `IRouter` prise en charge `EnableEndpointRouting` héritée, désactivez l' `Startup.ConfigureServices`une des approches suivantes dans :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Contrôles d’intégrité

Les contrôles d’intégrité peuvent être utilisés en tant que *routeur* avec routage des points de terminaison.

Ajoutez `MapHealthChecks` pour utiliser les vérifications d’intégrité avec routage du point de terminaison. La `MapHealthChecks` méthode accepte des arguments similaires `UseHealthChecks`à. L’avantage de l' `MapHealthChecks` utilisation `UseHealthChecks` de la valeur on est la possibilité d’appliquer une autorisation et d’avoir un contrôle plus précis de la stratégie de correspondance.

Dans l’exemple suivant, `MapHealthChecks` est appelé pour un point de terminaison de `/healthz`contrôle d’intégrité sur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3,0 utilisent l' [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient l' [hôte Web](xref:fundamentals/host/web-host). Le code suivant illustre la classe générée `Program` par le modèle ASP.net Core 3,0 :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant illustre la classe ASP.net Core 2,2 générée `Program` par le modèle :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>reste dans 3,0 et est le type de la `webBuilder` vue dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>sera dépréciée dans une version ultérieure et remplacée par `HostBuilder`.

La modification la plus significative `WebHostBuilder` de `HostBuilder` en est l' [injection de dépendances (di)](xref:fundamentals/dependency-injection). Lorsque vous `HostBuilder`utilisez, vous pouvez uniquement <xref:Microsoft.Extensions.Configuration.IConfiguration> injecter `Startup`et <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> dans le constructeur de. Contraintes `HostBuilder` di :

* Autorisez la génération du conteneur DI une seule fois.
* Évite les problèmes de durée de vie des objets résultants, tels que la résolution de plusieurs instances de singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization déplacé vers un autre assembly

Les méthodes ASP.net Core 2,2 et `AddAuthorization` Lower dans *Microsoft. AspNetCore. Authorization. dll*:

* Ont été renommés `AddAuthorizationCore`.
* Ont été déplacés vers *Microsoft. AspNetCore. Authorization. Policy. dll*.

Les applications qui utilisent à la fois *Microsoft. AspNetCore. Authorization. dll* et *Microsoft. AspNetCore. Authorization. Policy. dll* ne sont pas affectées.

Les applications qui n’utilisent pas *Microsoft. AspNetCore. Authorization. Policy. dll* doivent effectuer l’une des opérations suivantes :

* Basculer vers using`AddAuthorizationCore`
* Ajoutez une référence à *Microsoft. AspNetCore. Authorization. Policy. dll*.

Pour plus d’informations, consultez [modification avec `AddAuthorization(o =>`rupture dans) dans un assembly différent #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Le client JavaScript signalr est passé de `@aspnet/signalr` à `@microsoft/signalr`. Pour réagir à cette modification, modifiez les références dans les fichiers *Package. JSON* , `require` les instructions et `import` les instructions ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON est le protocole par défaut

`System.Text.Json`est maintenant le protocole de concentrateur par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, appelez `AddJsonProtocol` pour définir les options du sérialiseur.

**Serveurs**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculer vers Newtonsoft. JSON

Si vous utilisez des fonctionnalités de `Newtonsoft.Json` qui ne sont pas `System.Text.Json`prises en charge dans, vous `Newtonsoft.Json`pouvez revenir à :

1. Installez le package NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Sur le client, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `HubConnectionBuilder` à l’instance :

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sur le serveur, chaînez `AddNewtonsoftJsonProtocol` un appel de méthode `AddSignalR` à l’appel `Startup.ConfigureServices`de méthode dans :

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Accepter la compilation au moment de l’exécution

Dans 3,0, la compilation du runtime est un scénario d’abonnement. Pour activer la compilation au moment <xref:mvc/views/view-compilation#runtime-compilation>de l’exécution, consultez.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrer des bibliothèques via le multi-ciblage

Les bibliothèques doivent souvent prendre en charge plusieurs versions de ASP.NET Core. La plupart des bibliothèques qui ont été compilées avec des versions antérieures de ASP.NET Core doivent continuer à fonctionner sans problème. Les conditions suivantes nécessitent la compilation croisée de l’application :

* La bibliothèque s’appuie sur une fonctionnalité qui a une [modification avec rupture](#breaking-api-changes)binaire.
* La bibliothèque veut tirer parti des nouvelles fonctionnalités de ASP.NET Core 3,0. 

Exemple :

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Utilisez `#ifdefs` pour activer des API ASP.net Core 3,0 spécifiques :

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Interruption des modifications d’API

* [Liste complète des modifications avec rupture dans la version ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interruption des modifications d’API dans anti-contrefaçon, cors, diagnostics, MVC et routage](https://github.com/aspnet/Announcements/issues/387). Cette liste comprend les modifications avec rupture pour les commutateurs de compatibilité.
* Pour obtenir un résumé des modifications avec rupture 2,2 à 3,0 sur .NET Core, ASP.NET Core et Entity Framework Core, consultez [modifications avec rupture pour la migration de la version 2,2 vers 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 pas disponible actuellement pour la Azure App Service

Nous espérons que ce rendez-vous disponible prochainement. Tant que ASP.NET Core 3,0 n’est pas disponible sur Azure App Service, suivez les instructions de la procédure [déployer ASP.net core version préliminaire dans Azure App service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. Data. EntityFrameworkCore n’est actuellement pas pris en charge sur ASP.NET Core 3,0

Pour plus d’informations, consultez [ce problème GitHub](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
