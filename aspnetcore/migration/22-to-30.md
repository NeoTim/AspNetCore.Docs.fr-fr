---
title: Migrer de ASP.NET Core 2.2 à 3.0
author: rick-anderson
description: Apprenez à migrer un projet ASP.NET Core 2.2 pour ASP.NET Core 3.0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977234"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer de ASP.NET Core 2.2 à 3.0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet existant ASP.NET Core 2.2 pour ASP.NET Core 3.0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Mettre à jour la version du SDK .NET Core dans global.json

Si votre solution s’appuie sur un fichier [global.json](/dotnet/core/tools/global-json) pour cibler `version` une version spécifique .NET Core SDK, mettez à jour sa propriété sur la version 3.0 installée sur votre machine :

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Mettre à jour le dossier du projet

### <a name="update-the-target-framework"></a>Mettre à jour le cadre cible

ASP.NET Core 3.0 et plus tard ne s’exécutent que sur .NET Core. Définir le [Cadre-cadre cible Moniker (TFM)](/dotnet/standard/frameworks) à `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Supprimer les références de paquets obsolètes

Un grand nombre de paquets NuGet ne sont pas produits pour ASP.NET Core 3.0. Ces références de paquet doivent être supprimées de votre dossier de projet. Considérez le fichier de projet suivant pour une application web ASP.NET Core 2.2 :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Le dossier de projet mis à jour pour ASP.NET Core 3.0 :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Le fichier de projet ASP.NET Core 3.0 mis à jour :

* Dans le `<PropertyGroup>` :
  * Mise à jour du TFM pour`netcoreapp3.0`
  * Supprime l’élément. `<AspNetCoreHostingModel>` Pour plus d’informations, consultez [le modèle d’hébergement en cours](#in-process-hosting-model) dans ce document.

* Dans le `<ItemGroup>` :
  * `Microsoft.AspNetCore.App`est enlevé. Pour plus d’informations, voir [référence cadre](#framework-reference) dans ce document.
  * `Microsoft.AspNetCore.Razor.Design`est supprimé et dans la liste suivante des paquets qui ne sont plus produits.

Pour voir la liste complète des paquets qui ne sont plus produits, sélectionnez la liste d’extension suivante :

<details>
    <summary>Cliquez pour élargir la liste des paquets qui ne sont plus produits</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revoir les changements de rupture

[Revoir les changements de rupture](#break)

### <a name="framework-reference"></a>Référence du cadre

Les caractéristiques de ASP.NET Core qui étaient disponibles dans l’un des paquets énumérés ci-dessus sont disponibles dans le `Microsoft.AspNetCore.App` cadre partagé. Le *cadre partagé* est l’ensemble d’assemblages (fichiers *.dll)* qui sont installés sur la machine et comprend un composant de temps d’exécution et un pack de ciblage. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les projets `Microsoft.NET.Sdk.Web` qui ciblent le `Microsoft.AspNetCore.App` SDK font implicitement référence au cadre.

  Aucune référence supplémentaire n’est requise pour ces projets :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Les `Microsoft.NET.Sdk` projets `Microsoft.NET.Sdk.Razor` qui ciblent ou `FrameworkReference` SDK, doivent ajouter un explicite à `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Framework-dependent construit à l’aide de Docker

Les builds dépendants du cadre des applications de console qui utilisent un paquet qui dépend du [cadre partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET Core peuvent donner l’erreur de temps d’exécution suivante :

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`est le cadre partagé contenant le temps d’exécution ASP.NET Core et n’est présent que sur [l’image dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. Le 3.0 SDK réduit la taille des constructions dépendantes du cadre à l’aide de ASP.NET Core en n’incluant pas les copies en double des bibliothèques qui sont disponibles dans le cadre partagé. Il s’agit d’une économie potentielle allant jusqu’à 18 Mo, mais il exige que le ASP.NET Core runtime être présent / installé pour exécuter l’application.

Pour déterminer si l’application a une dépendance (directe ou indirecte) sur le cadre partagé ASP.NET Core, examinez le fichier *runtimeconfig.json* généré lors d’une version/publication de votre application. Le dossier JSON suivant montre une dépendance à l’égard du cadre partagé ASP.NET Core :

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si votre application utilise Docker, utilisez une image de base qui inclut ASP.NET Core 3.0. Par exemple : `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Ajouter des références de paquets pour les assemblages supprimés

ASP.NET Core 3.0 supprime certains assemblages qui faisaient `Microsoft.AspNetCore.App` auparavant partie de la référence du paquet. Pour visualiser les assemblages supprimés, comparez les deux dossiers-cadres partagés. Par exemple, une comparaison des versions 2.2.7 et 3.0.0 :

![comparaison des assemblées-cadres partagées](22-to-30/_static/assembly-diff.png)

Pour continuer à utiliser les fonctionnalités fournies par les assemblages supprimés, référencez les versions 3.0 des paquets correspondants :

* Une application Web générée par un modèle avec **des comptes utilisateur individuels** nécessite l’ajout des paquets suivants :

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Pour plus d’informations sur le référencement de l’ensemble spécifique au fournisseur de bases de données, voir [Les fournisseurs de bases de données](/ef/core/providers/index).

* Interface utilisateur d’identité

  La prise en charge [de l’interface utilisateur Identity](xref:security/authentication/identity) peut être ajoutée en faisant référence au package [Microsoft.AspNetCore.Identity.UI.](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)

* SPA Services

  * [Microsoft.AspNetCore.SpaServices (en anglais seulement)](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft.AspNetCore.SpaServices.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Le &ndash; support d’authentification pour les flux d’authentification tiers est disponible sous forme de forfaits NuGet :

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Authentification du compte Microsoft ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Authentification OpenID Connect ([Microsoft.AspNetCore.Authentication.OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect porte-personnes jeton ([Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Authentification WsFederation ([Microsoft.AspNetCore.Authentication.WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Le formatage et `System.Net.HttpClient` &ndash; le support de négociation de contenu pour le paquet [NuGet Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fournit une efficacité utile avec `System.Net.HttpClient` les API telles que `ReadAsAsync` et `PostJsonAsync`.

* Razor runtime &ndash; compilation Support for runtime compilation of Razor views and pages is now part of [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (Json.NET) support &ndash; Support for using `Newtonsoft.Json` MVC with is now part of [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Changements de démarrage

L’image suivante montre les lignes supprimées et modifiées dans une application Web ASP.NET Core 2.2 Razor Pages :

![les lignes supprimées et modifiées dans une application Web ASP.NET Core 2.2 Razor](22-to-30/_static/startup2.2.png)

Dans l’image précédente, le code supprimé est affiché en rouge. Le code supprimé n’affiche pas de code d’options de cookies, qui a été supprimé avant de comparer les fichiers.

L’image suivante montre les lignes ajoutées et modifiées dans une application Web ASP.NET Core 3.0 Razor Pages :

![les lignes ajoutées et modifiées dans une application Web De ASP.NET Core 3.0 Razor](22-to-30/_static/startup3.0.png)

Dans l’image précédente, le code ajouté est affiché en vert. Pour plus d’informations sur les modifications suivantes :

* `services.AddMvc`voir `services.AddRazorPages` [l’enregistrement du service MVC](#mvc-service-registration) dans ce document.
* `CompatibilityVersion`, <xref:mvc/compatibility-version>voir .
* `IHostingEnvironment`à `IWebHostEnvironment`, voir [cette annonce GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`a été ajouté aux modèles pour montrer l’autorisation de commande middleware doit être ajouté. Si l’application n’utilise pas l’autorisation, `app.UseAuthorization`vous pouvez supprimer l’appel en toute sécurité à .
* `app.UseEndpoints`, voir [Razor Pages](#razor-pages) ou [Migrate Startup.Configure](#migrate-startupconfigure) dans ce document.

### <a name="analyzer-support"></a>Soutien de l’analyseur

Projets `Microsoft.NET.Sdk.Web` qui ciblent implicitement des analyseurs de référence précédemment expédiés dans le cadre du paquet [Microsoft.AspNetCore.Mvc.Analyzers.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) Aucune référence supplémentaire n’est requise pour les activer.

Si votre application utilise [des analyseurs API](xref:web-api/advanced/analyzers) précédemment expédiés à l’aide du paquet [Microsoft.AspNetCore.Mvc.Api.Analyzers,](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) modifiez votre fichier de projet pour référencer les analyseurs expédiés dans le cadre du .NET Core Web SDK :

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Bibliothèque de classes Razor

Les projets de razor Class Library qui fournissent `AddRazorSupportForMvc` des composants d’assurance-chômage pour MVC doivent définir la propriété dans le dossier du projet :

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modèle d’hébergement in-process

Projets par défaut au [modèle d’hébergement en cours](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.NET Core 3.0 ou plus tard. Vous pouvez supprimer `<AspNetCoreHostingModel>` la propriété dans le fichier `InProcess`du projet si sa valeur est .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

Configuration De Miigérrel au constructeur `ConfigureWebHostDefaults` d’hébergeur web fourni par (*Program.cs*) :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si l’application crée l’hôte manuellement avec `HostBuilder`, faire appel `UseKestrel` au constructeur hébergeur dans `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Connection Middleware remplace les adaptateurs de connexion

Les adaptateurs`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`de connexion ( ) ont été supprimés de Kestrel. Remplacer les adaptateurs de connexion par Connection Middleware. Connexion Middleware est similaire à HTTP Middleware dans le pipeline ASP.NET Core, mais pour les connexions de niveau inférieur. HTTPS et l’enregistrement de connexion:

* Ont été déplacés de Connection Adapters à Connection Middleware.
* Ces méthodes d’extension fonctionnent comme dans les versions précédentes de ASP.NET Core. 

Pour plus d’informations, voir [l’exemple de TlsFilterConnectionHandler dans la section ListenOptions.Protocols de l’article Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Les abstractions de transport se sont déplacées et rendues publiques

La couche de transport Kestrel a `Connections.Abstractions`été exposée comme une interface publique dans . Dans le cadre de ces mises à jour :

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`et les types associés ont été supprimés.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>a été <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> déplacé des options de transport.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`a été <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>retiré de .

Pour plus d’informations, voir les ressources GitHub suivantes :

* [Abstractions de réseautage client/serveur (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implémentez la nouvelle abstraction de l’auditeur de base et re-plat Kestrel sur le dessus (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>En-têtes de remorque de Kestrel Request

Pour les applications qui ciblent les versions antérieures de ASP.NET Core :

* Kestrel ajoute HTTP/1.1 en-têtes de remorque en morceaux dans la collection d’en-têtes de demande.
* Les remorques sont disponibles après que le corps de demande soit lu jusqu’à la fin.

Cela provoque des préoccupations au sujet de l’ambiguïté entre les en-têtes et les remorques, de sorte que les remorques ont été déplacés vers une nouvelle collection (`RequestTrailerExtensions`) en 3.0.

LES bandes-annonces de demande HTTP/2 sont les :

* Non disponible en ASP.NET Core 2.2.
* Disponible en 3.0 as `RequestTrailerExtensions`.

De nouvelles méthodes d’extension de demande sont présentes pour accéder à ces remorques. Comme avec HTTP/1.1, les remorques sont disponibles après que le corps de demande soit lu jusqu’à la fin.

Pour la version 3.0, les méthodes suivantes `RequestTrailerExtensions` sont disponibles :

* `GetDeclaredTrailers`&ndash; Obtient l’en-tête de demande `Trailer` qui énumère quelles remorques à attendre après le corps.
* `SupportsTrailers`&ndash; Indique si la demande prend en charge la réception des en-têtes de remorque.
* `CheckTrailersAvailable`&ndash; Vérifie si la demande prend en charge les remorques et si elles sont disponibles pour être lues. Cette vérification ne suppose pas qu’il ya des remorques à lire. Il n’y a peut-être pas de remorques à lire même si cette `true` méthode est retournée.
* `GetTrailer`&ndash; Obtient l’en-tête de fuite demandé de la réponse. Vérifiez `SupportsTrailers` avant `GetTrailer`d’appeler, ou un <xref:System.NotSupportedException> peut se produire si la demande ne prend pas en charge les en-têtes de fuite.

Pour plus d’informations, voir [les bandes-annonces De la demande Put dans une collection distincte (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>PermettreSynchronousIO désactivé

`AllowSynchronousIO`permet ou désactive les API synchrones `HttpRequest.Body.Read`I/O, telles que , `HttpResponse.Body.Write`, et `Stream.Flush`. Ces API sont une source de famine de thread conduisant à des plantages d’applications. En 3.0, `AllowSynchronousIO` est désactivé par défaut. Pour plus d’informations, voir [la section Synchronous I/O dans l’article de Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Si une synchronisation I/O est nécessaire, elle peut `AllowSynchronousIO` être activée en configurant l’option sur le serveur utilisé (lors de l’appel, `ConfigureKestrel`par exemple, si vous utilisez Kestrel). Notez que les serveurs (Kestrel, HttpSys, TestServer, `AllowSynchronousIO` etc.) ont tous leur propre option qui n’affectera pas les autres serveurs. Synchronous I/O peut être activé pour tous les serveurs `IHttpBodyControlFeature.AllowSynchronousIO` sur une base par demande en utilisant l’option:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si vous avez <xref:System.IO.TextWriter> des problèmes avec les implémentations ou d’autres flux qui appellent des API synchrones dans [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), appelez plutôt la nouvelle <xref:System.IO.Stream.DisposeAsync*> API.

Pour plus d’informations, voir [[Annonce] AllowSynchronousIO désactivé dans tous les serveurs (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft.AspNetCore.Server.Kestrel.Https assemblage supprimé

Dans ASP.NET Core 2.1, le contenu de *Microsoft.AspNetCore.Server.Kestrel.https.dll* ont été transférés à *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Il s’agissait d’une mise à jour non-rupture en utilisant `TypeForwardedTo` des attributs. Pour 3.0, l’assemblage vide *de Microsoft.AspNetCore.Server.Kestrel.Https.dll* et le paquet NuGet ont été supprimés.

Les bibliothèques faisant référence à [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devraient mettre à jour ASP.NET dépendances de base à 2,1 ou plus tard.

Les applications et les bibliothèques ciblant ASP.NET Core 2.1 ou plus tard doivent supprimer toute référence directe au package [Microsoft.AspNetCore.Server.Kestrel.Https.](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Soutien de Newtonsoft.Json (Json.NET)

Dans le cadre des travaux visant à [améliorer le cadre partagé ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été retiré du cadre partagé ASP.NET Core.

Le sérialisateur JSON par défaut <xref:System.Text.Json>pour ASP.NET Core est maintenant , qui est nouveau dans .NET Core 3.0. Envisagez `System.Text.Json` d’utiliser lorsque c’est possible. Il est de haute performance et ne nécessite pas une dépendance supplémentaire de la bibliothèque. Cependant, `System.Text.Json` depuis qu’il est nouveau, il pourrait actuellement manquer des fonctionnalités dont votre application a besoin. Pour plus d’informations, voir [Comment migrer de Newtonsoft.Json à System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Utilisez Newtonsoft.Json dans un projet ASP.NET Core SignalR 3.0

* Installez le [SignalRMicrosoft.AspNetCore. . Paquet Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet.

* Sur le client, `AddNewtonsoftJsonProtocol` enchaîner un appel de méthode à l’instance `HubConnectionBuilder` :

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Sur le serveur, `AddNewtonsoftJsonProtocol` enchaîner un appel de méthode à la `AddSignalR` méthode appelez dans `Startup.ConfigureServices`:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Utilisez Newtonsoft.Json dans un projet ASP.NET Core 3.0 MVC

* Installez le package [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

* Mise `Startup.ConfigureServices` à `AddNewtonsoftJson`jour pour appeler .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`est compatible avec les nouvelles méthodes d’enregistrement des services MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`les paramètres peuvent être `AddNewtonsoftJson`définis dans l’appel à :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Note:** Si `AddNewtonsoftJson` la méthode n’est pas disponible, assurez-vous d’avoir installé le package [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Une erreur commune est d’installer le paquet [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) au lieu du paquet [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="mvc-service-registration"></a>Enregistrement du service MVC

ASP.NET Core 3.0 ajoute de nouvelles options pour l’enregistrement des scénarios MVC à l’intérieur `Startup.ConfigureServices`.

Trois nouvelles méthodes d’extension de haut `IServiceCollection` niveau liées aux scénarios MVC sont disponibles. Modèles utiliser ces nouvelles `AddMvc`méthodes au lieu de . Cependant, `AddMvc` continue de se comporter comme il l’a fait dans les versions précédentes.

L’exemple suivant ajoute la prise en charge des contrôleurs et des fonctionnalités liées à l’API, mais pas des vues ou des pages. Le modèle API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, des fonctionnalités liées à l’API et des vues, mais pas des pages. Le modèle d’application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge des pages Razor et du soutien minimal du contrôleur. Le modèle d’application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est `AddMvc` équivalent à l’appel dans ASP.NET Core 2.2 :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Code de démarrage de routage

Si une `UseMvc` application `UseSignalR`appelle ou, migrez l’application vers [Endpoint Routing](xref:fundamentals/routing) si possible. Pour améliorer la compatibilité de route de point de terminaison avec les versions précédentes de MVC, nous avons retourné quelques-uns des changements dans la génération d’URL introduits dans ASP.NET Core 2.2. Si vous avez éprouvé des problèmes en utilisant Endpoint Routing en 2.2, attendez-vous à des améliorations dans ASP.NET Core 3.0 avec les exceptions suivantes :

* Si l’application `IRouter` implémente ou hérite de `Route`, utilisez [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) comme remplacement.
* Si l’application `RouteData.Routers` accède directement à l’intérieur de MVC pour analyser les URL, vous pouvez le remplacer par l’utilisation de [LinkParser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Définissez l’itinéraire avec un nom d’itinéraire.
  * Utiliser `LinkParser.ParsePathByEndpointName` et passer dans le nom d’itinéraire souhaité.

Endpoint Routing prend en charge la même syntaxe de modèle d’itinéraire et les caractéristiques de l’auteur du modèle d’itinéraire que `IRouter`. Point d’arrêt `IRouteConstraint`Routing prend en charge . Endpoint routage `[Route]` `[HttpGet]`prend en charge , , et les autres attributs de routage MVC.

Pour la plupart `Startup` des applications, il ne faut que des modifications.

### <a name="migrate-startupconfigure"></a>Migre Startup.Configure

Conseil général :

* Ajoutez `UseRouting`.
* Si l’application `UseStaticFiles` `UseStaticFiles` appelle , **placez avant** `UseRouting`.
* Si l’application utilise des fonctionnalités d’authentification/autorisation `UseRouting` `UseCors`telles que `UseEndpoints` `AuthorizePage` ou `[Authorize]`, placez l’appel à `UseAuthentication` et `UseAuthorization`: **après**, et , mais avant :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Remplacer `UseMvc` `UseSignalR` ou `UseEndpoints`par .
* Si l’application utilise des scénarios [CORS,](xref:security/cors) tels `[EnableCors]`que , placer l’appel à `UseCors` `UseCors` avant `UseAuthentication` `UseAuthorization`tout autre middleware qui utilisent CORS (par exemple, place avant , , et `UseEndpoints`).
* `IHostingEnvironment` Remplacez `IWebHostEnvironment` et `using` ajoutez une <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> déclaration pour l’espace nom.
* Remplacer `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> par<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> (namespace).
* Remplacer `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> par<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> (namespace).

Le code suivant est `Startup.Configure` un exemple de dans une application ASP.NET Core 2.2 typique :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la `Startup.Configure` mise à jour du code précédent :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pour la plupart `UseAuthentication`des `UseAuthorization`applications, les appels à , et `UseCors` doivent apparaître entre les appels et `UseRouting` `UseEndpoints` pour être efficace.

### <a name="health-checks"></a>Contrôles d'intégrité

Les contrôles de santé utilisent le routage des points de terminaison avec l’hôte générique. Dans `Startup.Configure`, `MapHealthChecks` appelez le constructeur de point de terminaison avec l’URL de point de terminaison ou le chemin relatif :

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Les points de terminaison de contrôles de santé peuvent :

* Spécifier un ou plusieurs hôtes/ports autorisés.
* Exiger l’autorisation.
* Exigez CORS.

Pour plus d’informations, consultez <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Conseils de middleware de sécurité

Le support pour l’autorisation et corS est unifié autour de l’approche [middleware.](xref:fundamentals/middleware/index) Cela permet l’utilisation du même middleware et fonctionnalité à travers ces scénarios. Un middleware d’autorisation mis à jour est fourni dans cette version, et CORS Middleware est amélioré afin qu’il puisse comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS pouvait être difficile à configurer. Middleware a été fourni pour une utilisation dans certains cas d’utilisation, mais les filtres MVC ont été destinés à être utilisés **sans** le middleware dans d’autres cas d’utilisation. Avec ASP.NET Core 3.0, nous recommandons que toutes les applications qui nécessitent CORS utilisent le CORS Middleware en tandem avec Endpoint Routing. `UseCors`peut être fourni avec une `[EnableCors]` `[DisableCors]` stratégie par défaut, et les attributs peuvent être utilisés pour passer outre à la stratégie par défaut si nécessaire.

Dans l’exemple suivant :

* CORS est activé pour tous `default` les points de terminaison avec la stratégie nommée.
* La `MyController` classe désactive CORS avec l’attribut. `[DisableCors]`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorisation

Dans les versions antérieures de ASP.NET Core, le `[Authorize]` support d’autorisation a été fourni via l’attribut. Autorisation middleware n’était pas disponible. Dans ASP.NET Core 3.0, l’autorisation middleware est nécessaire. Nous vous recommandons de placer le ASP.NET`UseAuthorization`Core `UseAuthentication`Authorization Middleware ( ) immédiatement après . Le Middleware d’autorisation peut également être configuré avec une stratégie par défaut, qui peut être remplacée.

Dans ASP.NET Core 3.0 ou `UseAuthorization` plus tard, est `Startup.Configure` `HomeController` appelé, et ce qui suit nécessite un signé dans l’utilisateur:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Lors de l’utilisation du routage `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` de point de terminaison, nous recommandons de ne pas configurer et plutôt de compter sur le middleware Autorisation.  Si l’application `AuthorizeFilter` utilise un filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une politique dans l’appel à `AddAuthorization`.

Le `DefaultPolicy` est initialement configuré pour nécessiter l’authentification, de sorte qu’aucune configuration supplémentaire n’est nécessaire. Dans l’exemple suivant, les critères `RequireAuthorization` d’évaluation de MVC sont `DefaultPolicy`marqués de manière à ce que toutes les demandes soient autorisées en fonction de la . Cependant, `HomeController` l’accès permet sans que l’utilisateur se connecte à l’application en raison de `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorisation pour des critères d’évaluation spécifiques

L’autorisation peut également être configurée pour des classes spécifiques de points de terminaison. Le code suivant est un exemple de conversion d’une application MVC qui a configuré un global `AuthorizeFilter` en une application avec une politique spécifique nécessitant une autorisation :

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Les stratégies peuvent également être personnalisées. Le `DefaultPolicy` est configuré pour nécessiter l’authentification:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativement, tous les critères d’évaluation `[Authorize]` peuvent `RequireAuthorization` être configurés pour exiger l’autorisation sans ou en configurant un `FallbackPolicy`. L’est `FallbackPolicy` différent `DefaultPolicy`de la . Le `DefaultPolicy` est `[Authorize]` déclenché `RequireAuthorization`par `FallbackPolicy` ou , tandis que le est déclenché quand aucune autre stratégie n’est définie. `FallbackPolicy`est initialement configuré pour permettre des demandes sans autorisation.

L’exemple suivant est le `DefaultPolicy` même que `FallbackPolicy` l’exemple précédent, mais utilise `[AllowAnonymous]` le pour toujours exiger l’authentification sur tous les points de terminaison, sauf quand est spécifié:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

L’autorisation par middleware fonctionne sans que le cadre ait une connaissance spécifique de l’autorisation. Par exemple, [les contrôles de santé](xref:host-and-deploy/health-checks) n’ont aucune connaissance spécifique de l’autorisation, mais les contrôles de santé peuvent avoir une politique d’autorisation configurable appliquée par le middleware.

De plus, chaque point de terminaison peut personnaliser ses exigences d’autorisation. Dans l’exemple `UseAuthorization` suivant, `DefaultPolicy`traite l’autorisation avec le , mais le `/healthz` point de terminaison de bilan de santé exige un `admin` utilisateur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protection est mise en œuvre pour certains scénarios. Endpoints Middleware lance une exception si une autorisation ou une politique CORS est ignorée en raison de middleware manquant. Le soutien des analyseurs pour fournir des commentaires supplémentaires sur la mauvaise configuration est en cours.

#### <a name="custom-authorization-handlers"></a>Gestionnaires d’autorisation personnalisés

Si l’application utilise [des gestionnaires d’autorisation personnalisés,](xref:security/authorization/policies#authorization-handlers)le routage des points de terminaison passe un type de ressource différent aux gestionnaires de MVC. Les gestionnaires qui s’attendent à ce <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> que la ressource contextuelle du gestionnaire d’autorisation soit de <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> type (le type de ressources fournie par les [filtres MVC)](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)devront être mis à jour pour traiter les ressources de type (le type de ressources donné aux gestionnaires d’autorisation par itinéraire de point final).

MVC utilise `AuthorizationFilterContext` toujours des ressources, donc si l’application utilise des filtres d’autorisation MVC ainsi que l’autorisation de routage de point de terminaison, il peut être nécessaire de gérer les deux types de ressources.

### SignalR

La SignalR cartographie des hubs `UseEndpoints`a maintenant lieu à l’intérieur .

Carte de `MapHub`chaque hub avec . Comme dans les versions précédentes, chaque hub est explicitement répertorié.

Dans l’exemple suivant, `ChatHub` SignalR le support pour le hub est ajouté :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Il existe une nouvelle option pour contrôler les limites de taille des messages des clients. Par exemple, dans `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Dans ASP.NET Core 2.2, vous pouvez `TransportMaxBufferSize` définir le et qui contrôlerait efficacement la taille maximale du message. Dans ASP.NET Core 3.0, cette option ne contrôle plus que la taille maximale avant d’observer la rétropression.

### <a name="mvc-controllers"></a>Contrôleurs MVC

La cartographie des contrôleurs `UseEndpoints`a maintenant lieu à l’intérieur .

Ajoutez `MapControllers` si l’application utilise le routage d’attribut. Étant donné que le routage comprend la prise en charge de nombreux cadres dans ASP.NET Core 3.0 ou plus tard, l’ajout de contrôleurs acheminés par attribut est opt-in.

Remplacez le code suivant :

* `MapRoute` avec `MapControllerRoute`
* `MapAreaRoute` avec `MapAreaControllerRoute`

Depuis le routage comprend maintenant le soutien pour plus que juste MVC, la terminologie a changé pour faire ces méthodes clairement indiquer ce qu’ils font. Les itinéraires `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` conventionnels tels que sont appliqués dans l’ordre qu’ils sont ajoutés. Placez d’abord des itinéraires plus spécifiques (comme des itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers`ajoute un support pour les contrôleurs acheminés par attribut.
* `MapAreaControllerRoute`ajoute un itinéraire conventionnel pour les contrôleurs dans une zone.
* `MapControllerRoute`ajoute un itinéraire conventionnel pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Suppression du suffixe Async des noms d’action du contrôleur

Dans ASP.NET Core 3.0, ASP.NET Core MVC supprime `Async` le suffixe des noms d’action du contrôleur. Le routage et la génération de liaisons sont touchés par ce nouveau défaut. Par exemple :

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Avant ASP.NET Core 3.0:

* L’action précédente a pu être consultée sur la route *Produits/ListAsync.*
* La génération de `Async` lien nécessitait de spécifier le suffixe. Par exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

Dans ASP.NET Core 3.0:

* L’action précédente est accessible sur l’itinéraire *Produits/Liste.*
* La génération de liens ne `Async` nécessite pas de spécifier le suffixe. Par exemple :

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Cette modification n’affecte pas [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) les noms spécifiés à l’aide de l’attribut. Le comportement par défaut peut être `Startup.ConfigureServices`désactivé avec le code suivant dans :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Changements pour lier la génération

Comme expliqué dans la documentation sur [les différences par rapport aux versions antérieures du routage,](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)il existe certaines différences dans la génération de liens (en utilisant `Url.Link` et des API similaires, par exemple). notamment :

* Par défaut, lors de l’utilisation du routage de point final, le boîtier des paramètres d’itinéraire dans les URL générées n’est pas nécessairement préservé. Ce comportement peut être `IOutboundParameterTransformer` contrôlé avec l’interface.
* Générer un URI pour un itinéraire invalide (un contrôleur/action ou une page qui n’existe pas) produira une chaîne vide sous le routage de point de terminaison au lieu de produire une URI invalide.
* Les valeurs ambiantes (paramètres d’itinéraire du contexte actuel) ne sont pas automatiquement utilisées dans la génération de liens avec le routage de point final. Auparavant, lors de la création d’un lien vers une autre action (ou page), les valeurs d’itinéraire non spécifiées seraient déduites des valeurs ambiantes *actuelles.* Lors de l’utilisation du routage des points de terminaison, tous les paramètres d’itinéraire doivent être spécifiés explicitement pendant la génération de liens.

### <a name="razor-pages"></a>Pages Razor

Cartographier les pages `UseEndpoints`razor se déroule maintenant à l’intérieur .

Ajoutez `MapRazorPages` si l’application utilise Razor Pages. Étant donné que Endpoint Routing inclut la prise en charge de nombreux cadres, l’ajout de pages Razor est maintenant opt-in.

Dans la `Startup.Configure` méthode `MapRazorPages` suivante, ajoute la prise en charge des pages Razor :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans itinéraire de point d’arrêt

L’utilisation `UseMvc` de `UseMvcWithDefaultRoute` MVC via ou dans ASP.NET Core 3.0 nécessite un opt-in explicite à l’intérieur `Startup.ConfigureServices`. Cela est nécessaire parce que MVC doit savoir si elle peut s’appuyer sur l’autorisation et CORS Middleware lors de l’initialisation. Un analyseur est fourni qui avertit si l’application tente d’utiliser une configuration non supportée.

Si l’application `IRouter` nécessite un `EnableEndpointRouting` support hérité, désactiver `Startup.ConfigureServices`l’utilisation de l’une des approches suivantes dans :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Contrôles d'intégrité

Les contrôles de santé peuvent être utilisés comme *routeur-ware* avec Endpoint Routing.

Ajouter `MapHealthChecks` à utiliser des contrôles de santé avec Endpoint Routing. La `MapHealthChecks` méthode accepte des `UseHealthChecks`arguments similaires à . L’avantage `MapHealthChecks` d’utiliser le sur `UseHealthChecks` est la capacité d’appliquer l’autorisation et d’avoir un plus grand contrôle à grain fin sur la politique de jumelage.

Dans l’exemple `MapHealthChecks` suivant, est appelé pour `/healthz`un point de terminaison de bilan de santé à :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3.0 utilisent [Generic Host](xref:fundamentals/host/generic-host). Les versions précédentes utilisaient [Web Host](xref:fundamentals/host/web-host). Le code suivant affiche la classe générée `Program` par le modèle ASP.NET Core 3.0 :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant affiche la classe générée par `Program` le modèle ASP.NET Core 2.2 :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>reste dans 3.0 et est `webBuilder` le type de l’échantillon de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>sera déprécié dans une version `HostBuilder`future et remplacé par .

Le changement le `WebHostBuilder` `HostBuilder` plus important de la part est [l’injection de dépendance (DI).](xref:fundamentals/dependency-injection) Lors `HostBuilder`de l’utilisation, vous `Startup`ne pouvez injecter ce qui suit dans le constructeur de 's:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Les `HostBuilder` contraintes DI:

* Permettre de construire le conteneur DI une seule fois.
* Évite les problèmes de durée de vie de l’objet qui en résultent comme la résolution de multiples cas de singletons.

Pour plus d’informations, voir [l’injection de service Avoiding Startup dans ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization déplacé à un assemblage différent

Le ASP.NET Core 2.2 et `AddAuthorization` les méthodes inférieures dans *Microsoft.AspNetCore.Authorization.dll*:

* Ont été `AddAuthorizationCore`rebaptisés .
* Ont été transférés à *Microsoft.AspNetCore.Authorization.policy.dll*.

Les applications qui utilisent à la fois *Microsoft.AspNetCore.Authorization.dll* et *Microsoft.AspNetCore.Authorization.policy.dll* ne sont pas impactées.

Les applications qui n’utilisent pas *Microsoft.AspNetCore.Authorization.Policy.dll* devraient faire l’un des éléments suivants :

* Ajouter une référence à *Microsoft.AspNetCore.Authorization.Policy.dll*. Cette approche fonctionne pour la plupart des applications et est tout ce qui est nécessaire.
* Passer à l’utilisation`AddAuthorizationCore`

Pour plus d’informations, voir [Breaking change in `AddAuthorization(o =>`) surcharge vit dans un assemblage différent #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interface utilisateur d’identité

Mises à jour de l’interface utilisateur d’identité pour ASP.NET Core 3.0 :

* Ajoutez une référence de paquet à [Microsoft.AspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Les applications qui n’utilisent `MapRazorPages`pas Razor Pages doivent appeler . Voir [Les pages Razor](#razor-pages) dans ce document.
* Bootstrap 4 est le cadre d’interface utilisateur par défaut. Définissez `IdentityUIFrameworkVersion` une propriété de projet pour modifier la valeur par défaut. Pour plus d’informations, voir [cette annonce GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Le SignalR client JavaScript `@aspnet/signalr` est `@microsoft/signalr`passé de . Pour réagir à ce changement, modifiez les `require` références *dans* les `import` fichiers, les relevés et les relevés ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json est le protocole par défaut

`System.Text.Json`est maintenant le protocole Hub par défaut utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, `AddJsonProtocol` appelez pour définir des options de sérialisation.

**Serveur:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Passez à Newtonsoft.Json

Si vous utilisez [des fonctionnalités de Newtonsoft.Json qui ne sont pas pris en charge dans System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), vous pouvez revenir à `Newtonsoft.Json`. Voir [Use Newtonsoft.Json dans un ASP.NET projet Core SignalR 3.0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) plus tôt dans cet article.

## <a name="redis-distributed-caches"></a>Redis a distribué des caches

Le forfait [Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) n’est pas disponible pour ASP.NET’applications Core 3.0 ou plus tard. Remplacez la référence du paquet par [Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Pour plus d’informations, consultez <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Optez pour la compilation runtime

Avant ASP.NET Core 3.0, la compilation des vues en temps d’exécution était une caractéristique implicite du cadre. Les suppléments de compilation Runtime construisent-le-temps de la compilation des vues. Il permet au cadre de compiler les vues et les pages Razor (fichiers *.cshtml)* lorsque les fichiers sont modifiés, sans avoir à reconstruire l’application entière. Cette fonctionnalité prend en charge le scénario d’une modification rapide dans l’IDE et rafraîchissant le navigateur pour afficher les modifications.

Dans ASP.NET Core 3.0, la compilation runtime est un scénario d’opt-in. La compilation de build-time est le seul mécanisme de compilation d’images activé par défaut. L’exécution s’appuie sur Visual Studio ou [dotnet-watch](xref:tutorials/dotnet-watch) dans Visual Studio Code pour reconstruire le projet lorsqu’il détecte les modifications apportées aux fichiers *.cshtml.* Dans Visual Studio, les changements à *.cs*, *.cshtml*, ou *.razor* fichiers dans le projet en cours d’exécution (<kbd>Ctrl-F5</kbd>), mais pas débugged (<kbd>F5</kbd>), déclencher la recompilation du projet.

Pour activer la compilation en temps d’exécution dans votre projet ASP.NET Core 3.0 :

1. Installez le package [NuGet Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)
1. Mise `Startup.ConfigureServices` à `AddRazorRuntimeCompilation`jour pour appeler :

    Pour ASP.NET Core MVC, utilisez le code suivant :

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pour ASP.NET Pages de rasoir de base, utilisez le code suivant :
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
L’échantillon https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation montre un exemple de compilation de temps d’exécution conditionnellement dans les environnements de développement.

Pour plus d’informations sur <xref:mvc/views/view-compilation>la compilation de fichiers Razor, voir .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrer les bibliothèques via le multi-ciblage

Les bibliothèques ont souvent besoin de prendre en charge plusieurs versions de ASP.NET Core. La plupart des bibliothèques qui ont été compilées par rapport aux versions précédentes de ASP.NET Core devraient continuer à travailler sans problèmes. Les conditions suivantes exigent que l’application soit compilée en contrecoup :

* La bibliothèque s’appuie sur une fonctionnalité qui a un changement de [rupture](#breaking-api-changes)binaire .
* La bibliothèque veut profiter de nouvelles fonctionnalités dans ASP.NET Core 3.0. 

Par exemple :

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Utiliser `#ifdefs` pour activer ASP.NET API spécifiques à base 3.0 :

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Pour plus d’informations sur l’utilisation de ASP.NET <xref:fundamentals/target-aspnetcore>API de base dans une bibliothèque de classe, voir .

## <a name="miscellaneous-changes"></a>Modifications diverses

Le système de validation en .NET Core 3.0 et traite plus tard des `[Required]` paramètres non annulables ou des propriétés liées comme s’ils avaient un attribut. Pour plus d’informations, voir [[requis] attribut](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publish

Supprimer les *dossiers bin* et *obj* dans l’annuaire du projet.

## <a name="testserver"></a>TestServer

Pour les <xref:Microsoft.AspNetCore.TestHost.TestServer> applications qui utilisent directement `TestServer` avec <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> l’hôte [générique](xref:fundamentals/host/web-host), créer le sur un dans <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Briser les changements d’API

Examen des changements de rupture:

* [Liste complète des changements de rupture dans la version ASP.NET Core 3.0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Briser les changements d’API dans l’antiforgerie, corS, diagnostics, MVC, et le routage](https://github.com/aspnet/Announcements/issues/387). Cette liste comprend des modifications de rupture pour les commutateurs de compatibilité.
* Pour un résumé de 2,2 à 3,0 changements de rupture à travers .NET Core, ASP.NET Core, et Entity Framework Core, voir [Breaking changements pour la migration de la version 2.2 à 3.0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3.0 sur Azure App Service

Pour progresser sur le déploiement de .NET Core to Azure App Service, voir le site officiel [.NET Core sur App Service.](https://aspnetcoreon.azurewebsites.net/) Jusqu’à ce que .NET Core 3.0 soit disponible sur Azure App Service, suivez les instructions de [La version de l’aperçu De Deploy ASP.NET Core sur Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
