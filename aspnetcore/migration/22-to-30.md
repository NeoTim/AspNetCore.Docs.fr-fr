---
title: Migrer d’ASP.NET Core 2.2 à 3.0 Preview
author: tdykstra
description: Découvrez comment migrer un projet ASP.NET Core 2.2 vers ASP.NET Core 3.0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 06/17/2019
uid: migration/22-to-30
ms.openlocfilehash: 1499239ae94919d1b094e6e55970d9920c4da2cd
ms.sourcegitcommit: 8516b586541e6ba402e57228e356639b85dfb2b9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/11/2019
ms.locfileid: "67814867"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrer d’ASP.NET Core 2.2 à 3.0

Par [Scott Addie](https://github.com/scottaddie) et [Rick Anderson](https://twitter.com/RickAndMSFT)

Cet article explique comment mettre à jour un projet ASP.NET Core 2.2 existant vers ASP.NET Core 3.0.

## <a name="prerequisites"></a>Prérequis

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pour Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Mettre à jour le fichier projet

* Définir le [Moniker du Framework (TFM) cible](/dotnet/standard/frameworks) à `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Supprimez les `<PackageReference>` à la [Microsoft.AspNetCore.All](xref:fundamentals/metapackage) ou [Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) métapackage.

* Mise à jour le `Version` attribut sur restant `<PackageReference>` éléments pour `Microsoft.AspNetCore.*` packages pour la version préliminaire actuelle (par exemple, `3.0.0-preview5-19227-01`).

  S’il n’existe aucune version 3.0 d’un package, le package peut ont été déconseillé dans 3.0. La plupart de ces packages sont partie `Microsoft.AspNetCore.App` et ne doit pas être référencées individuellement. Pour obtenir une liste préliminaire des packages ne sont plus produites dans 3.0, consultez [cesser de produire des packages pour les assemblys du framework partagé dans 3.0 (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). Le *framework partagé* est le jeu d’assemblys ( *.dll* fichiers) qui sont installés sur l’ordinateur et référencé par `Microsoft.AspNetCore.App`. Pour plus d’informations, consultez [Le framework partagé](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Les assemblys pour plusieurs composants importants ont été supprimés `Microsoft.AspNetCore.App` 3.0. Ajouter `<PackageReference>` éléments si vous utilisez des API à partir de packages répertoriés dans [Microsoft.AspNetCore.App 3.0 en cours de suppression des assemblys (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Voici quelques exemples de composants supprimés :

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  La liste des assemblys d’expédition dans `Microsoft.AspNetCore.App` n’a pas été finalisées et changera avant la version RTM 3.0.

  Examinons le code ci-dessous.

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Le `ReadAsAsync` méthode appelée dans le code précédent est inclus dans `Microsoft.AspNet.WebApi.Client`. Installer le [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) package NuGet pour résoudre le problème de compilation dans 3.0.

* Ajouter [prise en charge de Json.NET](#jsonnet-support).

* Projets par défaut pour le [modèle d’hébergement intra-processus](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) dans ASP.NET Core 3.0 ou version ultérieure. Vous pouvez éventuellement supprimer le `<AspNetCoreHostingModel>` propriété dans le fichier projet si sa valeur est `InProcess`.

## <a name="jsonnet-support"></a>Prise en charge de Json.NET

Dans le cadre du travail à [améliorer framework ASP.NET Core partagé](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) a été supprimé de l’infrastructure partagée ASP.NET Core.

Pour utiliser Json.NET dans un projet ASP.NET Core 3.0 :

* Ajouter une référence de package à [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Mise à jour `Startup.ConfigureServices` pour appeler `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson` est compatible avec les nouvelles méthodes d’inscription de service MVC :

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Paramètres de Json.NET peuvent être définis dans l’appel à `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Inscription du service de MVC

ASP.NET Core 3.0 ajoute de nouvelles options pour l’inscription des scénarios MVC à l’intérieur de `Startup.ConfigureServices`.

Trois nouvelles méthodes d’extension de niveau supérieur relatives aux scénarios MVC sur `IServiceCollection` sont disponibles. Les modèles utilisent ces nouvelles méthodes au lieu de `UseMvc`. Toutefois, `AddMvc` continue à se comporter comme il a dans les versions précédentes.

L’exemple suivant ajoute la prise en charge pour les contrôleurs et fonctionnalités API, mais pas les vues ou pages. Le modèle d’API utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

L’exemple suivant ajoute la prise en charge des contrôleurs, API-fonctionnalités et les vues, mais pas les pages. Le modèle d’Application Web (MVC) utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

L’exemple suivant ajoute la prise en charge pour les Pages Razor et prise en charge du contrôleur minimal. Le modèle d’Application Web utilise ce code :

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Les nouvelles méthodes peuvent également être combinées. L’exemple suivant est équivalent à l’appel `AddMvc` dans ASP.NET Core 2.2 : 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Mettre à jour le code de démarrage du routage

Si une application appelle `UseMvc` ou `UseSignalR`, migrer l’application à [routage de point de terminaison](xref:fundamentals/routing) si possible. Pour améliorer la compatibilité de routage de point de terminaison avec les versions précédentes de MVC, nous avons rétabli certaines modifications dans la génération d’URL introduite dans ASP.NET Core 2.2. Si vous avez rencontré des problèmes à l’aide de routage de point de terminaison dans 2.2, attendre des améliorations dans ASP.NET Core 3.0 avec les exceptions suivantes :

* Si l’application implémente `IRouter` ou hérite `Route`, vous pouvez souhaiter éviter la migration pour l’instant. Fournir des commentaires à [planifier la migration des implémentations IRouter basé sur le point de terminaison de routage](https://github.com/aspnet/AspNetCore/issues/4221).

* Si l’application accède directement à `RouteData.Routers` à l’intérieur de MVC, vous pouvez souhaiter éviter la migration pour l’instant. Fournir des commentaires à [conseils de Migration pour l’utilisation de RouteData.Routers](https://github.com/aspnet/AspNetCore/issues/9148).

Routage de point de terminaison prend en charge la même syntaxe de modèle d’itinéraire et la création de fonctionnalités en tant que modèle d’itinéraire `IRouter`. Prend en charge du routage de point de terminaison `IRouteContraint`. Prend en charge du routage de point de terminaison `[Route]`, `[HttpGet]`et les autres attributs de routage MVC.

Pour la plupart des applications, uniquement `Startup` nécessite des modifications.

### <a name="migrate-startupconfigure"></a>Migrer Startup.Configure

Conseils généraux :

* Ajouter `UseRouting`. 
* Si l’application appelle `UseStaticFiles`, placez `UseStaticFiles` **avant** `UseRouting`.
* Si l’application utilise les fonctionnalités d’authentification/autorisation telle que `AuthorizePage` ou `[Authorize]`, placez l’appel à `UseAuthentication` et `UseAuthorization` **après** `UseRouting`.
* Si l’application utilise [CORS](xref:security/cors) fonctionnalités, telles que `[EnableCors]`, placez `UseCors` suivant.
* Remplacez `UseMvc` ou `UseSignalR` avec `UseEndpoints`.

Voici un exemple de `Startup.Configure` dans une application ASP.NET Core 2.2 classique :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Après la mise à jour précédente `Startup.Configure` code :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Conseils de sécurité intergiciel (middleware)

Prise en charge pour l’autorisation et CORS est unifiée autour de la [intergiciel (middleware)](xref:fundamentals/middleware/index) approche. Cela permet l’utilisation de l’intergiciel (middleware) même et les fonctionnalités dans ces scénarios. Un intergiciel (middleware) d’autorisation de mise à jour est fourni dans cette version, et intergiciel (middleware) CORS a été amélioré afin qu’il puisse comprendre les attributs utilisés par les contrôleurs MVC.

#### <a name="cors"></a>CORS

Auparavant, CORS peut être difficile à configurer. Intergiciel (middleware) a été fourni pour utilisation dans certains cas d’utilisation, mais les filtres MVC ont été destinés à être utilisé **sans** l’intergiciel (middleware) dans d’autres cas d’usage. Avec ASP.NET Core 3.0, nous recommandons que toutes les applications qui nécessitent des CORS utiliser l’intergiciel (middleware) CORS en tandem avec le point de terminaison de routage. `UseCors` peut être fourni avec une stratégie par défaut, et `[EnableCors]` et `[DisableCors]` attributs peuvent être utilisés pour remplacer la stratégie par défaut si nécessaire. 

Dans l’exemple suivant :

* CORS est activé pour tous les points de terminaison avec le `default` stratégie nommée.
* Le `MyController` classe désactive CORS avec le `[DisableCors]` attribut.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Dans les versions antérieures d’ASP.NET Core, la prise en charge de l’autorisation a été fourni par le `[Authorize]` attribut. Intergiciel (middleware) d’autorisation n’était pas disponible. Dans ASP.NET Core 3.0, l’intergiciel (middleware) d’autorisation est nécessaire. Nous vous recommandons de placer l’intergiciel de l’autorisation ASP.NET Core (`UseAuthorization`) immédiatement après `UseAuthentication`. L’intergiciel (middleware) d’autorisation peut également être configuré avec une stratégie par défaut, ce qui peut être remplacée.

Dans ASP.NET Core 3.0 ou version ultérieure, `UseAuthorization` est appelée `Startup.Configure`et ce qui suit `HomeController` nécessite ouvert la session utilisateur :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si l’application utilise un `AuthorizeFilter` comme un filtre global dans MVC, nous vous recommandons de refactoriser le code pour fournir une stratégie pour le `UseAuthorization` intergiciel (middleware).

Dans l’exemple suivant, une stratégie personnalisée à appliquer à toutes les demandes quand `UseAuthorization` est appelée et le `HomeController` autorise l’accès sans que l’utilisateur de connexion à l’application :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Autorisation de l’intergiciel (middleware) fonctionne sans l’infrastructure n’aient connaissance spécifique de l’autorisation. Par exemple, [vérifications d’intégrité](xref:host-and-deploy/health-checks) n’a aucune connaissance spécifique de l’autorisation, mais les contrôles d’intégrité peuvent avoir une stratégie d’autorisation configurable appliquée par l’intergiciel (middleware).

Dans l’exemple suivant, `UseAuthorization` traite d’autorisation sans une stratégie par défaut, mais la `/healthz` point de terminaison de vérification d’intégrité, l’utilisateur doit se trouver dans le `admin` rôle : 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Implémentation de la protection pour certains scénarios. `UseEndpoint` intergiciel (middleware) lève une exception si une autorisation ou une stratégie CORS est ignorée en raison de l’intergiciel (middleware) manquant. La prise en charge de l’analyseur pour fournir des commentaires supplémentaires sur une configuration incorrecte sont en cours.

### <a name="migrate-signalr"></a>Migrer de SignalR

Le mappage de concentrateurs SignalR maintenant a lieu à l’intérieur de `UseEndpoints`. 

Mapper chaque hub avec `MapHub`. Comme dans les versions précédentes, chaque concentrateur est explicitement répertorié.

Dans l’exemple suivant, la prise en charge pour le `ChatHub` concentrateur SignalR est ajoutée :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Migrer des contrôleurs MVC

Le mappage des contrôleurs maintenant a lieu à l’intérieur de `UseEndpoints`. 

Ajouter `MapControllers` si l’application utilise le routage par attributs. Étant donné que le routage inclut la prise en charge de nombreuses infrastructures dans ASP.NET Core 3.0 ou version ultérieure, l’ajout de contrôleurs routées par l’attribut est participer. 

Remplacez les éléments suivants :

* `MapRoute` Avec `MapControllerRoute`
* `MapAreaRoute` Avec `MapAreaControllerRoute`

Étant donné que le routage maintenant inclut la prise en charge de plus que MVC, la terminologie a changé pour rendre ces méthodes indiquent clairement ce qu’ils font. Les routes conventionnelles comme `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` sont appliquées dans l’ordre qu’ils sont ajoutés. Placer en premier les itinéraires plus spécifiques (par exemple, les itinéraires pour une zone).

Dans l’exemple suivant :

* `MapControllers` Ajoute la prise en charge des contrôleurs routées par l’attribut.
* `MapAreaControllerRoute` Ajoute une route conventionnelle pour les contrôleurs dans une zone.
* `MapControllerRoute` Ajoute une route conventionnelle pour les contrôleurs.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Migrer des Pages Razor

Mappage des Pages Razor maintenant a lieu à l’intérieur de `UseEndpoints`.

Ajouter `MapRazorPages` si l’application utilise les Pages Razor. Étant donné que le routage de point de terminaison comprend la prise en charge pour la plupart des infrastructures, l’ajout de que pages Razor est désormais participer.

Dans l’exemple suivant, `MapRazorPages` ajoute la prise en charge pour les Pages Razor :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Utiliser MVC sans routage de point de terminaison

À l’aide de MVC via `UseMvc` ou `UseMvcWithDefaultRoute` dans ASP.NET Core 3.0 nécessite explicite participer à l’intérieur de `Startup.ConfigureServices`. Cela est nécessaire, car MVC doit savoir si se fier à l’autorisation et l’intergiciel (middleware) CORS pendant l’initialisation. Un analyseur est fournie qui vous avertit si l’application tente d’utiliser une configuration non prise en charge.

Si l’application requiert hérité `IRouter` prennent en charge, désactivez `EnableEndpointRouting` en utilisant l’une de ces approches dans `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Migrer des contrôles d’intégrité

Contrôles d’intégrité peuvent être utilisées comme un *routeur des logiciels espions* avec le routage de point de terminaison.

Ajouter `MapHealthChecks` à utiliser le contrôle d’intégrité vérifie avec le routage de point de terminaison. Le `MapHealthChecks` méthode accepte des arguments similaire à `UseHealthChecks`. L’avantage d’utiliser `MapHealthChecks` sur `UseHealthChecks` est la possibilité d’appliquer d’autorisation et d’avoir un meilleur contrôle affiné sur la stratégie de correspondance. 

Dans l’exemple suivant, `MapHealthChecks` est appelée pour un point de terminaison de vérification d’intégrité à `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder remplace WebHostBuilder

Les modèles ASP.NET Core 3.0 utilisent [hôte générique](xref:fundamentals/host/generic-host). Les versions précédentes utilisées [hôte Web](xref:fundamentals/host/web-host). Le code suivant montre le modèle ASP.NET Core 3.0 généré `Program` classe :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Le code suivant montre la 2.2 Core ASP.NET modèle généré `Program` classe :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> reste dans 3.0 et est le type de la `webBuilder` vu dans l’exemple de code précédent. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> sera déconseillée dans une version ultérieure et remplacé par `HostBuilder`.

La modification la plus importante à partir de `WebHostBuilder` à `HostBuilder` est dans [l’injection de dépendance (DI)](xref:fundamentals/dependency-injection). Lorsque vous utilisez `HostBuilder`, vous pouvez injecter uniquement <xref:Microsoft.Extensions.Configuration.IConfiguration> et <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> dans `Startup`du constructeur. Le `HostBuilder` les contraintes de l’injection de dépendances :

* Activer le conteneur d’injection de dépendance à générer qu’une seule fois.
* Permet d’éviter les problèmes de durée de vie objet résultant comme la résolution de plusieurs instances de singletons.

## <a name="update-signalr-code"></a>Mettre à jour le code de SignalR

`System.Text.Json` est désormais la valeur par défaut Hub protocole utilisé par le client et le serveur.

Dans `Startup.ConfigureServices`, appelez `AddJsonProtocol` pour définir les options de sérialiseur.

**Serveur :**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client :**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Basculez vers Newtonsoft.Json

Si vous utilisez des fonctionnalités de `Newtonsoft.Json` qui ne sont pas pris en charge dans `System.Text.Json`, vous pouvez basculer vers `Newtonsoft.Json`:

1. Installer le [Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) package NuGet.
1. Sur le client, chaîner une `AddNewtonsoftJsonProtocol` appel de méthode à la `HubConnectionBuilder` instance :

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Sur le serveur, chaîner une `AddNewtonsoftJsonProtocol` appel de méthode à la `AddSignalR` appel de méthode dans `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>S’abonner à la compilation pour le runtime

Dans 3.0, la compilation pour le runtime est un scénario opt-in. Pour activer la compilation pour le runtime, consultez <xref:mvc/views/view-compilation#runtime-compilation>.
