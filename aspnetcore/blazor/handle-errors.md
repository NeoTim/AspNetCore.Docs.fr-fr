---
title: Gérer les erreurs dans les applications ASP.NET Core éblouissantes
author: guardrex
description: Découvrez comment l’ASP.NET Core éblouissants gère les exceptions non gérées et comment développer des applications qui détectent et gèrent les erreurs.
monikerRange: '>= aspnetcore-3.0'
ms.author: riande
ms.custom: mvc
ms.date: 08/06/2019
uid: blazor/handle-errors
ms.openlocfilehash: d3e261e83f375574339a8ce3428e8bfb73df4307
ms.sourcegitcommit: 092061c4f6ef46ed2165fa84de6273d3786fb97e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/13/2019
ms.locfileid: "70963986"
---
# <a name="handle-errors-in-aspnet-core-blazor-apps"></a><span data-ttu-id="04d36-103">Gérer les erreurs dans les applications ASP.NET Core éblouissantes</span><span class="sxs-lookup"><span data-stu-id="04d36-103">Handle errors in ASP.NET Core Blazor apps</span></span>

<span data-ttu-id="04d36-104">Par [Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="04d36-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

<span data-ttu-id="04d36-105">Cet article explique comment éblouissant gère les exceptions non gérées et comment développer des applications qui détectent et gèrent les erreurs.</span><span class="sxs-lookup"><span data-stu-id="04d36-105">This article describes how Blazor manages unhandled exceptions and how to develop apps that detect and handle errors.</span></span>

## <a name="how-the-blazor-framework-reacts-to-unhandled-exceptions"></a><span data-ttu-id="04d36-106">Comment le Framework éblouissant réagit aux exceptions non gérées</span><span class="sxs-lookup"><span data-stu-id="04d36-106">How the Blazor framework reacts to unhandled exceptions</span></span>

<span data-ttu-id="04d36-107">Le serveur éblouissant est un Framework avec état.</span><span class="sxs-lookup"><span data-stu-id="04d36-107">Blazor Server is a stateful framework.</span></span> <span data-ttu-id="04d36-108">Tandis que les utilisateurs interagissent avec une application, ils maintiennent une connexion au serveur appelé « *circuit*».</span><span class="sxs-lookup"><span data-stu-id="04d36-108">While users interact with an app, they maintain a connection to the server known as a *circuit*.</span></span> <span data-ttu-id="04d36-109">Le circuit contient des instances de composant actives, ainsi que de nombreux autres aspects de l’État, tels que :</span><span class="sxs-lookup"><span data-stu-id="04d36-109">The circuit holds active component instances, plus many other aspects of state, such as:</span></span>

* <span data-ttu-id="04d36-110">Sortie du rendu le plus récent des composants.</span><span class="sxs-lookup"><span data-stu-id="04d36-110">The most recent rendered output of components.</span></span>
* <span data-ttu-id="04d36-111">Ensemble actuel de délégués de gestion d’événements qui peuvent être déclenchés par les événements côté client.</span><span class="sxs-lookup"><span data-stu-id="04d36-111">The current set of event-handling delegates that could be triggered by client-side events.</span></span>

<span data-ttu-id="04d36-112">Si un utilisateur ouvre l’application dans plusieurs onglets de navigateur, il dispose de plusieurs circuits indépendants.</span><span class="sxs-lookup"><span data-stu-id="04d36-112">If a user opens the app in multiple browser tabs, they have multiple independent circuits.</span></span>

<span data-ttu-id="04d36-113">Éblouissant traite la plupart des exceptions non gérées comme étant irrécupérables par le circuit dans lequel elles se produisent.</span><span class="sxs-lookup"><span data-stu-id="04d36-113">Blazor treats most unhandled exceptions as fatal to the circuit where they occur.</span></span> <span data-ttu-id="04d36-114">Si un circuit est arrêté en raison d’une exception non gérée, l’utilisateur ne peut continuer à interagir avec l’application qu’en rechargeant la page pour créer un nouveau circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-114">If a circuit is terminated due to an unhandled exception, the user can only continue to interact with the app by reloading the page to create a new circuit.</span></span> <span data-ttu-id="04d36-115">Les circuits en dehors de celui qui est terminé, qui sont des circuits pour d’autres utilisateurs ou d’autres onglets de navigateur, ne sont pas affectés.</span><span class="sxs-lookup"><span data-stu-id="04d36-115">Circuits outside of the one that's terminated, which are circuits for other users or other browser tabs, aren't affected.</span></span> <span data-ttu-id="04d36-116">Ce scénario est similaire à une application de bureau qui&mdash;bloque l’application bloquée doit être redémarrée, mais les autres applications ne sont pas affectées.</span><span class="sxs-lookup"><span data-stu-id="04d36-116">This scenario is similar to a desktop app that crashes&mdash;the crashed app must be restarted, but other apps aren't affected.</span></span>

<span data-ttu-id="04d36-117">Un circuit se termine lorsqu’une exception non gérée se produit pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="04d36-117">A circuit is terminated when an unhandled exception occurs for the following reasons:</span></span>

* <span data-ttu-id="04d36-118">Une exception non gérée rend souvent le circuit dans un État indéfini.</span><span class="sxs-lookup"><span data-stu-id="04d36-118">An unhandled exception often leaves the circuit in an undefined state.</span></span>
* <span data-ttu-id="04d36-119">L’opération normale de l’application ne peut pas être garantie après une exception non gérée.</span><span class="sxs-lookup"><span data-stu-id="04d36-119">The app's normal operation can't be guaranteed after an unhandled exception.</span></span>
* <span data-ttu-id="04d36-120">Des failles de sécurité peuvent apparaître dans l’application si le circuit continue.</span><span class="sxs-lookup"><span data-stu-id="04d36-120">Security vulnerabilities may appear in the app if the circuit continues.</span></span>

## <a name="manage-unhandled-exceptions-in-developer-code"></a><span data-ttu-id="04d36-121">Gérer les exceptions non gérées dans le code du développeur</span><span class="sxs-lookup"><span data-stu-id="04d36-121">Manage unhandled exceptions in developer code</span></span>

<span data-ttu-id="04d36-122">Pour qu’une application continue après une erreur, l’application doit avoir une logique de gestion des erreurs.</span><span class="sxs-lookup"><span data-stu-id="04d36-122">For an app to continue after an error, the app must have error handling logic.</span></span> <span data-ttu-id="04d36-123">Les sections suivantes de cet article décrivent les sources potentielles d’exceptions non gérées.</span><span class="sxs-lookup"><span data-stu-id="04d36-123">Later sections of this article describe potential sources of unhandled exceptions.</span></span>

<span data-ttu-id="04d36-124">En production, ne rendez pas les messages d’exception d’infrastructure ou les traces de pile dans l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="04d36-124">In production, don't render framework exception messages or stack traces in the UI.</span></span> <span data-ttu-id="04d36-125">Le rendu des messages d’exception ou des traces de pile peut :</span><span class="sxs-lookup"><span data-stu-id="04d36-125">Rendering exception messages or stack traces could:</span></span>

* <span data-ttu-id="04d36-126">Divulguer des informations sensibles aux utilisateurs finaux.</span><span class="sxs-lookup"><span data-stu-id="04d36-126">Disclose sensitive information to end users.</span></span>
* <span data-ttu-id="04d36-127">Aidez un utilisateur malveillant à découvrir des faiblesses dans une application qui peuvent compromettre la sécurité de l’application, du serveur ou du réseau.</span><span class="sxs-lookup"><span data-stu-id="04d36-127">Help a malicious user discover weaknesses in an app that can compromise the security of the app, server, or network.</span></span>

## <a name="log-errors-with-a-persistent-provider"></a><span data-ttu-id="04d36-128">Consigner les erreurs avec un fournisseur persistant</span><span class="sxs-lookup"><span data-stu-id="04d36-128">Log errors with a persistent provider</span></span>

<span data-ttu-id="04d36-129">Si une exception non gérée se produit, l’exception est consignée <xref:Microsoft.Extensions.Logging.ILogger> dans les instances configurées dans le conteneur de service.</span><span class="sxs-lookup"><span data-stu-id="04d36-129">If an unhandled exception occurs, the exception is logged to <xref:Microsoft.Extensions.Logging.ILogger> instances configured in the service container.</span></span> <span data-ttu-id="04d36-130">Par défaut, les applications éblouissantes se connectent à la sortie de la console avec le fournisseur de journalisation de la console.</span><span class="sxs-lookup"><span data-stu-id="04d36-130">By default, Blazor apps log to console output with the Console Logging Provider.</span></span> <span data-ttu-id="04d36-131">Envisagez de vous connecter à un emplacement plus permanent avec un fournisseur qui gère la taille du journal et la rotation des journaux.</span><span class="sxs-lookup"><span data-stu-id="04d36-131">Consider logging to a more permanent location with a provider that manages log size and log rotation.</span></span> <span data-ttu-id="04d36-132">Pour plus d'informations, consultez <xref:fundamentals/logging/index>.</span><span class="sxs-lookup"><span data-stu-id="04d36-132">For more information, see <xref:fundamentals/logging/index>.</span></span>

<span data-ttu-id="04d36-133">Lors du développement, éblouissant envoie généralement les détails complets des exceptions à la console du navigateur pour faciliter le débogage.</span><span class="sxs-lookup"><span data-stu-id="04d36-133">During development, Blazor usually sends the full details of exceptions to the browser's console to aid in debugging.</span></span> <span data-ttu-id="04d36-134">En production, les erreurs détaillées dans la console du navigateur sont désactivées par défaut, ce qui signifie que les erreurs ne sont pas envoyées aux clients, mais que les détails complets de l’exception sont toujours consignés côté serveur.</span><span class="sxs-lookup"><span data-stu-id="04d36-134">In production, detailed errors in the browser's console are disabled by default, which means that errors aren't sent to clients but the exception's full details are still logged server-side.</span></span> <span data-ttu-id="04d36-135">Pour plus d'informations, consultez <xref:fundamentals/error-handling>.</span><span class="sxs-lookup"><span data-stu-id="04d36-135">For more information, see <xref:fundamentals/error-handling>.</span></span>

<span data-ttu-id="04d36-136">Vous devez choisir les incidents à enregistrer et le niveau de gravité des incidents journalisés.</span><span class="sxs-lookup"><span data-stu-id="04d36-136">You must decide which incidents to log and the level of severity of logged incidents.</span></span> <span data-ttu-id="04d36-137">Les utilisateurs hostiles peuvent être en mesure de déclencher délibérément des erreurs.</span><span class="sxs-lookup"><span data-stu-id="04d36-137">Hostile users might be able to trigger errors deliberately.</span></span> <span data-ttu-id="04d36-138">Par exemple, ne consignez pas un incident à partir d' `ProductId` une erreur où un inconnu est fourni dans l’URL d’un composant qui affiche les détails du produit.</span><span class="sxs-lookup"><span data-stu-id="04d36-138">For example, don't log an incident from an error where an unknown `ProductId` is supplied in the URL of a component that displays product details.</span></span> <span data-ttu-id="04d36-139">Toutes les erreurs ne doivent pas être traitées comme des incidents de gravité élevée pour la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-139">Not all errors should be treated as high-severity incidents for logging.</span></span>

## <a name="places-where-errors-may-occur"></a><span data-ttu-id="04d36-140">Emplacements où des erreurs peuvent se produire</span><span class="sxs-lookup"><span data-stu-id="04d36-140">Places where errors may occur</span></span>

<span data-ttu-id="04d36-141">Le code d’infrastructure et d’application peut déclencher des exceptions non prises en charge dans l’un des emplacements suivants :</span><span class="sxs-lookup"><span data-stu-id="04d36-141">Framework and app code may trigger unhandled exceptions in any of the following locations:</span></span>

* [<span data-ttu-id="04d36-142">Instanciation du composant</span><span class="sxs-lookup"><span data-stu-id="04d36-142">Component instantiation</span></span>](#component-instantiation)
* [<span data-ttu-id="04d36-143">Méthodes de cycle de vie</span><span class="sxs-lookup"><span data-stu-id="04d36-143">Lifecycle methods</span></span>](#lifecycle-methods)
* [<span data-ttu-id="04d36-144">Logique de rendu</span><span class="sxs-lookup"><span data-stu-id="04d36-144">Rendering logic</span></span>](#rendering-logic)
* [<span data-ttu-id="04d36-145">Gestionnaires d’événements</span><span class="sxs-lookup"><span data-stu-id="04d36-145">Event handlers</span></span>](#event-handlers)
* [<span data-ttu-id="04d36-146">Suppression de composants</span><span class="sxs-lookup"><span data-stu-id="04d36-146">Component disposal</span></span>](#component-disposal)
* [<span data-ttu-id="04d36-147">Interopérabilité JavaScript</span><span class="sxs-lookup"><span data-stu-id="04d36-147">JavaScript interop</span></span>](#javascript-interop)
* [<span data-ttu-id="04d36-148">Gestionnaires de circuits</span><span class="sxs-lookup"><span data-stu-id="04d36-148">Circuit handlers</span></span>](#circuit-handlers)
* [<span data-ttu-id="04d36-149">Élimination de circuit</span><span class="sxs-lookup"><span data-stu-id="04d36-149">Circuit disposal</span></span>](#circuit-disposal)
* [<span data-ttu-id="04d36-150">Préaffichant</span><span class="sxs-lookup"><span data-stu-id="04d36-150">Prerendering</span></span>](#prerendering)

<span data-ttu-id="04d36-151">Les exceptions non gérées précédentes sont décrites dans les sections suivantes de cet article.</span><span class="sxs-lookup"><span data-stu-id="04d36-151">The preceding unhandled exceptions are described in the following sections of this article.</span></span>

### <a name="component-instantiation"></a><span data-ttu-id="04d36-152">Instanciation du composant</span><span class="sxs-lookup"><span data-stu-id="04d36-152">Component instantiation</span></span>

<span data-ttu-id="04d36-153">Quand éblouissant crée une instance d’un composant :</span><span class="sxs-lookup"><span data-stu-id="04d36-153">When Blazor creates an instance of a component:</span></span>

* <span data-ttu-id="04d36-154">Le constructeur du composant est appelé.</span><span class="sxs-lookup"><span data-stu-id="04d36-154">The component's constructor is invoked.</span></span>
* <span data-ttu-id="04d36-155">Les constructeurs de tout service d’injection de services non Singleton fourni au constructeur du composant via la [@inject](xref:blazor/dependency-injection#request-a-service-in-a-component) directive ou l’attribut [[Inject]](xref:blazor/dependency-injection#request-a-service-in-a-component) sont appelés.</span><span class="sxs-lookup"><span data-stu-id="04d36-155">The constructors of any non-singleton DI services supplied to the component's constructor via the [@inject](xref:blazor/dependency-injection#request-a-service-in-a-component) directive or the [[Inject]](xref:blazor/dependency-injection#request-a-service-in-a-component) attribute are invoked.</span></span> 

<span data-ttu-id="04d36-156">Un circuit échoue quand un constructeur exécuté ou une méthode setter pour `[Inject]` une propriété lève une exception non gérée.</span><span class="sxs-lookup"><span data-stu-id="04d36-156">A circuit fails when any executed constructor or a setter for any `[Inject]` property throws an unhandled exception.</span></span> <span data-ttu-id="04d36-157">L’exception est irrécupérable, car l’infrastructure ne peut pas instancier le composant.</span><span class="sxs-lookup"><span data-stu-id="04d36-157">The exception is fatal because the framework can't instantiate the component.</span></span> <span data-ttu-id="04d36-158">Si la logique du constructeur peut lever des exceptions, l’application doit intercepter les exceptions à l’aide d’une instruction [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec la gestion des erreurs et la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-158">If constructor logic may throw exceptions, the app should trap the exceptions using a [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statement with error handling and logging.</span></span>

### <a name="lifecycle-methods"></a><span data-ttu-id="04d36-159">Méthodes de cycle de vie</span><span class="sxs-lookup"><span data-stu-id="04d36-159">Lifecycle methods</span></span>

<span data-ttu-id="04d36-160">Pendant la durée de vie d’un composant, éblouissant appelle les méthodes de cycle de vie :</span><span class="sxs-lookup"><span data-stu-id="04d36-160">During the lifetime of a component, Blazor invokes lifecycle methods:</span></span>

* `OnInitialized` / `OnInitializedAsync`
* `OnParametersSet` / `OnParametersSetAsync`
* `ShouldRender` / `ShouldRenderAsync`
* `OnAfterRender` / `OnAfterRenderAsync`

<span data-ttu-id="04d36-161">Si une méthode de cycle de vie lève une exception, de manière synchrone ou asynchrone, l’exception est irrémédiable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-161">If any lifecycle method throws an exception, synchronously or asynchronously, the exception is fatal to the circuit.</span></span> <span data-ttu-id="04d36-162">Pour les composants qui gèrent les erreurs dans les méthodes de cycle de vie, ajoutez une logique de gestion des erreurs.</span><span class="sxs-lookup"><span data-stu-id="04d36-162">For components to deal with errors in lifecycle methods, add error handling logic.</span></span>

<span data-ttu-id="04d36-163">Dans l’exemple suivant, `OnParametersSetAsync` où appelle une méthode pour obtenir un produit :</span><span class="sxs-lookup"><span data-stu-id="04d36-163">In the following example where `OnParametersSetAsync` calls a method to obtain a product:</span></span>

* <span data-ttu-id="04d36-164">Une exception levée dans la `ProductRepository.GetProductByIdAsync` méthode est gérée par `try-catch` une instruction.</span><span class="sxs-lookup"><span data-stu-id="04d36-164">An exception thrown in the `ProductRepository.GetProductByIdAsync` method is handled by a `try-catch` statement.</span></span>
* <span data-ttu-id="04d36-165">Lorsque le `catch` bloc est exécuté :</span><span class="sxs-lookup"><span data-stu-id="04d36-165">When the `catch` block is executed:</span></span>
  * <span data-ttu-id="04d36-166">`loadFailed`a la valeur `true`, qui est utilisée pour afficher un message d’erreur à l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="04d36-166">`loadFailed` is set to `true`, which is used to display an error message to the user.</span></span>
  * <span data-ttu-id="04d36-167">L’erreur est consignée.</span><span class="sxs-lookup"><span data-stu-id="04d36-167">The error is logged.</span></span>

[!code-cshtml[](handle-errors/samples_snapshot/3.x/product-details.razor?highlight=11,27-39)]

### <a name="rendering-logic"></a><span data-ttu-id="04d36-168">Logique de rendu</span><span class="sxs-lookup"><span data-stu-id="04d36-168">Rendering logic</span></span>

<span data-ttu-id="04d36-169">Le balisage déclaratif dans un `.razor` fichier de composant est compilé dans C# une méthode `BuildRenderTree`appelée.</span><span class="sxs-lookup"><span data-stu-id="04d36-169">The declarative markup in a `.razor` component file is compiled into a C# method called `BuildRenderTree`.</span></span> <span data-ttu-id="04d36-170">Lorsqu’un composant affiche, `BuildRenderTree` exécute et génère une structure de données décrivant les éléments, le texte et les composants enfants du composant rendu.</span><span class="sxs-lookup"><span data-stu-id="04d36-170">When a component renders, `BuildRenderTree` executes and builds up a data structure describing the elements, text, and child components of the rendered component.</span></span>

<span data-ttu-id="04d36-171">La logique de rendu peut lever une exception.</span><span class="sxs-lookup"><span data-stu-id="04d36-171">Rendering logic can throw an exception.</span></span> <span data-ttu-id="04d36-172">Un exemple de ce scénario se produit `@someObject.PropertyName` lorsque est évalué `@someObject` , `null`mais est.</span><span class="sxs-lookup"><span data-stu-id="04d36-172">An example of this scenario occurs when `@someObject.PropertyName` is evaluated but `@someObject` is `null`.</span></span> <span data-ttu-id="04d36-173">Une exception non gérée levée par la logique de rendu est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-173">An unhandled exception thrown by rendering logic is fatal to the circuit.</span></span>

<span data-ttu-id="04d36-174">Pour éviter une exception de référence null dans la logique de rendu, `null` recherchez un objet avant d’accéder à ses membres.</span><span class="sxs-lookup"><span data-stu-id="04d36-174">To prevent a null reference exception in rendering logic, check for a `null` object before accessing its members.</span></span> <span data-ttu-id="04d36-175">Dans l’exemple suivant, `person.Address` les propriétés ne sont `person.Address` pas `null`accessibles si est :</span><span class="sxs-lookup"><span data-stu-id="04d36-175">In the following example, `person.Address` properties aren't accessed if `person.Address` is `null`:</span></span>

[!code-cshtml[](handle-errors/samples_snapshot/3.x/person-example.razor?highlight=1)]

<span data-ttu-id="04d36-176">Le code précédent suppose que `person` ne l’est pas. `null`</span><span class="sxs-lookup"><span data-stu-id="04d36-176">The preceding code assumes that `person` isn't `null`.</span></span> <span data-ttu-id="04d36-177">Souvent, la structure du code garantit l’existence d’un objet au moment du rendu du composant.</span><span class="sxs-lookup"><span data-stu-id="04d36-177">Often, the structure of the code guarantees that an object exists at the time the component is rendered.</span></span> <span data-ttu-id="04d36-178">Dans ce cas, il n’est pas nécessaire de `null` Rechercher dans la logique de rendu.</span><span class="sxs-lookup"><span data-stu-id="04d36-178">In those cases, it isn't necessary to check for `null` in rendering logic.</span></span> <span data-ttu-id="04d36-179">Dans l’exemple précédent, `person` peut être garanti qu’il existe `person` , car est créé lorsque le composant est instancié.</span><span class="sxs-lookup"><span data-stu-id="04d36-179">In the prior example, `person` might be guaranteed to exist because `person` is created when the component is instantiated.</span></span>

### <a name="event-handlers"></a><span data-ttu-id="04d36-180">Gestionnaires d’événements</span><span class="sxs-lookup"><span data-stu-id="04d36-180">Event handlers</span></span>

<span data-ttu-id="04d36-181">Le code côté client déclenche des appels de code lors C# de la création de gestionnaires d’événements à l’aide de :</span><span class="sxs-lookup"><span data-stu-id="04d36-181">Client-side code triggers invocations of C# code when event handlers are created using:</span></span>

* `@onclick`
* `@onchange`
* <span data-ttu-id="04d36-182">Autres `@on...` attributs</span><span class="sxs-lookup"><span data-stu-id="04d36-182">Other `@on...` attributes</span></span>
* `@bind`

<span data-ttu-id="04d36-183">Le code du gestionnaire d’événements peut lever une exception non gérée dans ces scénarios.</span><span class="sxs-lookup"><span data-stu-id="04d36-183">Event handler code might throw an unhandled exception in these scenarios.</span></span>

<span data-ttu-id="04d36-184">Si un gestionnaire d’événements lève une exception non gérée (par exemple, une requête de base de données échoue), l’exception est irrémédiable au circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-184">If an event handler throws an unhandled exception (for example, a database query fails), the exception is fatal to the circuit.</span></span> <span data-ttu-id="04d36-185">Si l’application appelle du code qui pourrait échouer pour des raisons externes, interceptez les exceptions à l’aide d’une instruction [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec gestion des erreurs et journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-185">If the app calls code that could fail for external reasons, trap exceptions using a [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statement with error handling and logging.</span></span>

<span data-ttu-id="04d36-186">Si le code utilisateur n’intercepte pas et ne gère pas l’exception, le Framework journalise l’exception et met fin au circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-186">If user code doesn't trap and handle the exception, the framework logs the exception and terminates the circuit.</span></span>

### <a name="component-disposal"></a><span data-ttu-id="04d36-187">Suppression de composants</span><span class="sxs-lookup"><span data-stu-id="04d36-187">Component disposal</span></span>

<span data-ttu-id="04d36-188">Un composant peut être supprimé de l’interface utilisateur, par exemple, parce que l’utilisateur a accédé à une autre page.</span><span class="sxs-lookup"><span data-stu-id="04d36-188">A component may be removed from the UI, for example, because the user has navigated to another page.</span></span> <span data-ttu-id="04d36-189">Quand un composant qui implémente <xref:System.IDisposable?displayProperty=fullName> est supprimé de l’interface utilisateur, le Framework appelle la méthode <xref:System.IDisposable.Dispose*> du composant.</span><span class="sxs-lookup"><span data-stu-id="04d36-189">When a component that implements <xref:System.IDisposable?displayProperty=fullName> is removed from the UI, the framework calls the component's <xref:System.IDisposable.Dispose*> method.</span></span> 

<span data-ttu-id="04d36-190">Si la méthode du `Dispose` composant lève une exception non gérée, l’exception est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-190">If the component's `Dispose` method throws an unhandled exception, the exception is fatal to the circuit.</span></span> <span data-ttu-id="04d36-191">Si la logique de suppression peut lever des exceptions, l’application doit intercepter les exceptions à l’aide d’une instruction [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec la gestion des erreurs et la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-191">If disposal logic may throw exceptions, the app should trap the exceptions using a [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statement with error handling and logging.</span></span>

<span data-ttu-id="04d36-192">Pour plus d’informations sur la suppression de <xref:blazor/components#component-disposal-with-idisposable>composants, consultez.</span><span class="sxs-lookup"><span data-stu-id="04d36-192">For more information on component disposal, see <xref:blazor/components#component-disposal-with-idisposable>.</span></span>

### <a name="javascript-interop"></a><span data-ttu-id="04d36-193">Interopérabilité JavaScript</span><span class="sxs-lookup"><span data-stu-id="04d36-193">JavaScript interop</span></span>

<span data-ttu-id="04d36-194">`IJSRuntime.InvokeAsync<T>`permet au code .NET d’effectuer des appels asynchrones au runtime JavaScript dans le navigateur de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="04d36-194">`IJSRuntime.InvokeAsync<T>` allows .NET code to make asynchronous calls to the JavaScript runtime in the user's browser.</span></span>

<span data-ttu-id="04d36-195">Les conditions suivantes s’appliquent à la `InvokeAsync<T>`gestion des erreurs avec :</span><span class="sxs-lookup"><span data-stu-id="04d36-195">The following conditions apply to error handling with `InvokeAsync<T>`:</span></span>

* <span data-ttu-id="04d36-196">Si un appel à `InvokeAsync<T>` échoue de façon synchrone, une exception .net se produit.</span><span class="sxs-lookup"><span data-stu-id="04d36-196">If a call to `InvokeAsync<T>` fails synchronously, a .NET exception occurs.</span></span> <span data-ttu-id="04d36-197">Un appel à `InvokeAsync<T>` mon échec, par exemple, car les arguments fournis ne peuvent pas être sérialisés.</span><span class="sxs-lookup"><span data-stu-id="04d36-197">A call to `InvokeAsync<T>` my fail, for example, because the supplied arguments can't be serialized.</span></span> <span data-ttu-id="04d36-198">Le code du développeur doit intercepter l’exception.</span><span class="sxs-lookup"><span data-stu-id="04d36-198">Developer code must catch the exception.</span></span> <span data-ttu-id="04d36-199">Si le code d’application dans une méthode de gestionnaire d’événements ou de cycle de vie de composant ne gère pas une exception, l’exception résultante est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-199">If app code in an event handler or component lifecycle method doesn't handle an exception, the resulting exception is fatal to the circuit.</span></span>
* <span data-ttu-id="04d36-200">Si un appel à `InvokeAsync<T>` échoue de manière asynchrone, le <xref:System.Threading.Tasks.Task> .net échoue.</span><span class="sxs-lookup"><span data-stu-id="04d36-200">If a call to `InvokeAsync<T>` fails asynchronously, the .NET <xref:System.Threading.Tasks.Task> fails.</span></span> <span data-ttu-id="04d36-201">Un appel à `InvokeAsync<T>` peut échouer, par exemple, parce que le code côté JavaScript lève une exception ou retourne un `Promise` qui s’est `rejected`terminé comme.</span><span class="sxs-lookup"><span data-stu-id="04d36-201">A call to `InvokeAsync<T>` may fail, for example, because the JavaScript-side code throws an exception or returns a `Promise` that completed as `rejected`.</span></span> <span data-ttu-id="04d36-202">Le code du développeur doit intercepter l’exception.</span><span class="sxs-lookup"><span data-stu-id="04d36-202">Developer code must catch the exception.</span></span> <span data-ttu-id="04d36-203">Si vous utilisez l’opérateur [await](/dotnet/csharp/language-reference/keywords/await) , encapsulez l’appel de méthode dans une instruction [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec la gestion des erreurs et la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-203">If using the [await](/dotnet/csharp/language-reference/keywords/await) operator, consider wrapping the method call in a [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statement with error handling and logging.</span></span> <span data-ttu-id="04d36-204">Dans le cas contraire, le code défaillant entraîne une exception non gérée qui est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-204">Otherwise, the failing code results in an unhandled exception that's fatal to the circuit.</span></span>
* <span data-ttu-id="04d36-205">Par défaut, les appels `InvokeAsync<T>` à doivent se terminer dans un laps de temps donné, sinon l’appel expire. Le délai d’expiration par défaut est d’une minute.</span><span class="sxs-lookup"><span data-stu-id="04d36-205">By default, calls to `InvokeAsync<T>` must complete within a certain period or else the call times out. The default timeout period is one minute.</span></span> <span data-ttu-id="04d36-206">Le délai d’attente protège le code contre toute perte de connectivité réseau ou de code JavaScript qui ne renvoie jamais de message d’achèvement.</span><span class="sxs-lookup"><span data-stu-id="04d36-206">The timeout protects the code against a loss in network connectivity or JavaScript code that never sends back a completion message.</span></span> <span data-ttu-id="04d36-207">Si l’appel expire, le résultant `Task` échoue avec un <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="04d36-207">If the call times out, the resulting `Task` fails with an <xref:System.OperationCanceledException>.</span></span> <span data-ttu-id="04d36-208">Interceptez et traitez l’exception avec la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-208">Trap and process the exception with logging.</span></span>

<span data-ttu-id="04d36-209">De même, le code JavaScript peut initier des appels à des méthodes .NET indiquées par l' [attribut [JSInvokable]](xref:blazor/javascript-interop#invoke-net-methods-from-javascript-functions).</span><span class="sxs-lookup"><span data-stu-id="04d36-209">Similarly, JavaScript code may initiate calls to .NET methods indicated by the [[JSInvokable] attribute](xref:blazor/javascript-interop#invoke-net-methods-from-javascript-functions).</span></span> <span data-ttu-id="04d36-210">Si ces méthodes .NET lèvent une exception non gérée :</span><span class="sxs-lookup"><span data-stu-id="04d36-210">If these .NET methods throw an unhandled exception:</span></span>

* <span data-ttu-id="04d36-211">L’exception n’est pas traitée comme étant irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-211">The exception isn't treated as fatal to the circuit.</span></span>
* <span data-ttu-id="04d36-212">Le côté `Promise` JavaScript est rejeté.</span><span class="sxs-lookup"><span data-stu-id="04d36-212">The JavaScript-side `Promise` is rejected.</span></span>

<span data-ttu-id="04d36-213">Vous avez la possibilité d’utiliser le code de gestion des erreurs côté .NET ou JavaScript de l’appel de méthode.</span><span class="sxs-lookup"><span data-stu-id="04d36-213">You have the option of using error handling code on either the .NET side or the JavaScript side of the method call.</span></span>

<span data-ttu-id="04d36-214">Pour plus d'informations, consultez <xref:blazor/javascript-interop>.</span><span class="sxs-lookup"><span data-stu-id="04d36-214">For more information, see <xref:blazor/javascript-interop>.</span></span>

### <a name="circuit-handlers"></a><span data-ttu-id="04d36-215">Gestionnaires de circuits</span><span class="sxs-lookup"><span data-stu-id="04d36-215">Circuit handlers</span></span>

<span data-ttu-id="04d36-216">Éblouissant permet au code de définir un *Gestionnaire de circuit*, qui reçoit des notifications lorsque l’état du circuit d’un utilisateur change.</span><span class="sxs-lookup"><span data-stu-id="04d36-216">Blazor allows code to define a *circuit handler*, which receives notifications when the state of a user's circuit changes.</span></span> <span data-ttu-id="04d36-217">Les États suivants sont utilisés :</span><span class="sxs-lookup"><span data-stu-id="04d36-217">The following states are used:</span></span>

* `initialized`
* `connected`
* `disconnected`
* `disposed`

<span data-ttu-id="04d36-218">Les notifications sont gérées en inscrivant un service d’injection `CircuitHandler` de services qui hérite de la classe de base abstraite.</span><span class="sxs-lookup"><span data-stu-id="04d36-218">Notifications are managed by registering a DI service that inherits from the `CircuitHandler` abstract base class.</span></span>

<span data-ttu-id="04d36-219">Si les méthodes d’un gestionnaire de circuit personnalisé lèvent une exception non gérée, l’exception est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-219">If a custom circuit handler's methods throw an unhandled exception, the exception is fatal to the circuit.</span></span> <span data-ttu-id="04d36-220">Pour tolérer des exceptions dans le code d’un gestionnaire ou les méthodes appelées, encapsulez le code dans une ou plusieurs instructions [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec la gestion des erreurs et la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-220">To tolerate exceptions in a handler's code or called methods, wrap the code in one or more [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statements with error handling and logging.</span></span>

### <a name="circuit-disposal"></a><span data-ttu-id="04d36-221">Élimination de circuit</span><span class="sxs-lookup"><span data-stu-id="04d36-221">Circuit disposal</span></span>

<span data-ttu-id="04d36-222">Lorsqu’un circuit se termine parce qu’un utilisateur s’est déconnecté et que l’infrastructure nettoie l’état du circuit, le Framework supprime l’étendue de l’injection de port.</span><span class="sxs-lookup"><span data-stu-id="04d36-222">When a circuit ends because a user has disconnected and the framework is cleaning up the circuit state, the framework disposes of the circuit's DI scope.</span></span> <span data-ttu-id="04d36-223">La suppression de l’étendue supprime tous les services d’étendue de circuit qui implémentent <xref:System.IDisposable?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="04d36-223">Disposing the scope disposes any circuit-scoped DI services that implement <xref:System.IDisposable?displayProperty=fullName>.</span></span> <span data-ttu-id="04d36-224">Si un service d’injection de services lève une exception non gérée pendant la suppression, le Framework journalise l’exception.</span><span class="sxs-lookup"><span data-stu-id="04d36-224">If any DI service throws an unhandled exception during disposal, the framework logs the exception.</span></span>

### <a name="prerendering"></a><span data-ttu-id="04d36-225">Préaffichant</span><span class="sxs-lookup"><span data-stu-id="04d36-225">Prerendering</span></span>

<span data-ttu-id="04d36-226">Les composants éblouissant peuvent être prérendus à `Html.RenderComponentAsync` l’aide de afin que le balisage HTML rendu soit renvoyé dans le cadre de la requête http initiale de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="04d36-226">Blazor components can be prerendered using `Html.RenderComponentAsync` so that their rendered HTML markup is returned as part of the user's initial HTTP request.</span></span> <span data-ttu-id="04d36-227">Cela fonctionne de la façon suivante :</span><span class="sxs-lookup"><span data-stu-id="04d36-227">This works by:</span></span>

* <span data-ttu-id="04d36-228">Création d’un nouveau circuit contenant tous les composants prérendus qui font partie de la même page.</span><span class="sxs-lookup"><span data-stu-id="04d36-228">Creating a new circuit containing all of the prerendered components that are part of the same page.</span></span>
* <span data-ttu-id="04d36-229">Génération du code HTML initial.</span><span class="sxs-lookup"><span data-stu-id="04d36-229">Generating the initial HTML.</span></span>
* <span data-ttu-id="04d36-230">Traiter le circuit comme `disconnected` jusqu’à ce que le navigateur de l’utilisateur établisse une connexion signalr au même serveur pour reprendre l’interactivité sur le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-230">Treating the circuit as `disconnected` until the user's browser establishes a SignalR connection back to the same server to resume interactivity on the circuit.</span></span>

<span data-ttu-id="04d36-231">Si un composant lève une exception non gérée pendant le prérendu, par exemple, pendant une méthode de cycle de vie ou dans une logique de rendu :</span><span class="sxs-lookup"><span data-stu-id="04d36-231">If any component throws an unhandled exception during prerendering, for example, during a lifecycle method or in rendering logic:</span></span>

* <span data-ttu-id="04d36-232">L’exception est irrécupérable pour le circuit.</span><span class="sxs-lookup"><span data-stu-id="04d36-232">The exception is fatal to the circuit.</span></span>
* <span data-ttu-id="04d36-233">L’exception est levée dans la pile des appels de `Html.RenderComponentAsync` l’appel.</span><span class="sxs-lookup"><span data-stu-id="04d36-233">The exception is thrown up the call stack from the `Html.RenderComponentAsync` call.</span></span> <span data-ttu-id="04d36-234">Par conséquent, la requête HTTP entière échoue, sauf si l’exception est explicitement interceptée par le code du développeur.</span><span class="sxs-lookup"><span data-stu-id="04d36-234">Therefore, the entire HTTP request fails unless the exception is explicitly caught by developer code.</span></span>

<span data-ttu-id="04d36-235">Dans des circonstances normales, lorsque le prérendu échoue, la création et le rendu du composant n’ont pas de sens, car un composant de travail ne peut pas être rendu.</span><span class="sxs-lookup"><span data-stu-id="04d36-235">Under normal circumstances when prerendering fails, continuing to build and render the component doesn't make sense because a working component can't be rendered.</span></span>

<span data-ttu-id="04d36-236">Pour tolérer les erreurs qui peuvent se produire pendant le prérendu, la logique de gestion des erreurs doit être placée à l’intérieur d’un composant qui peut lever des exceptions.</span><span class="sxs-lookup"><span data-stu-id="04d36-236">To tolerate errors that may occur during prerendering, error handling logic must be placed inside a component that may throw exceptions.</span></span> <span data-ttu-id="04d36-237">Utilisez les instructions [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) avec la gestion des erreurs et la journalisation.</span><span class="sxs-lookup"><span data-stu-id="04d36-237">Use [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) statements with error handling and logging.</span></span> <span data-ttu-id="04d36-238">Au lieu d’encapsuler `RenderComponentAsync` l’appel `try-catch` à dans une instruction, placez la logique de gestion des `RenderComponentAsync`erreurs dans le composant rendu par.</span><span class="sxs-lookup"><span data-stu-id="04d36-238">Instead of wrapping the call to `RenderComponentAsync` in a `try-catch` statement, place error handling logic in the component rendered by `RenderComponentAsync`.</span></span>

## <a name="advanced-scenarios"></a><span data-ttu-id="04d36-239">Scénarios avancés</span><span class="sxs-lookup"><span data-stu-id="04d36-239">Advanced scenarios</span></span>

### <a name="recursive-rendering"></a><span data-ttu-id="04d36-240">Rendu récursif</span><span class="sxs-lookup"><span data-stu-id="04d36-240">Recursive rendering</span></span>

<span data-ttu-id="04d36-241">Les composants peuvent être imbriqués de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="04d36-241">Components can be nested recursively.</span></span> <span data-ttu-id="04d36-242">Cela est utile pour représenter des structures de données récursives.</span><span class="sxs-lookup"><span data-stu-id="04d36-242">This is useful for representing recursive data structures.</span></span> <span data-ttu-id="04d36-243">Par exemple, un `TreeNode` composant peut restituer `TreeNode` plus de composants pour chacun des enfants du nœud.</span><span class="sxs-lookup"><span data-stu-id="04d36-243">For example, a `TreeNode` component can render more `TreeNode` components for each of the node's children.</span></span>

<span data-ttu-id="04d36-244">Lors du rendu de manière récursive, évitez les modèles de codage qui se traduisent par une récurrence infinie :</span><span class="sxs-lookup"><span data-stu-id="04d36-244">When rendering recursively, avoid coding patterns that result in infinite recursion:</span></span>

* <span data-ttu-id="04d36-245">Ne rendez pas de manière récursive une structure de données qui contient un cycle.</span><span class="sxs-lookup"><span data-stu-id="04d36-245">Don't recursively render a data structure that contains a cycle.</span></span> <span data-ttu-id="04d36-246">Par exemple, n’affichez pas un nœud d’arbre dont les enfants s’y trouvent.</span><span class="sxs-lookup"><span data-stu-id="04d36-246">For example, don't render a tree node whose children includes itself.</span></span>
* <span data-ttu-id="04d36-247">Ne créez pas une chaîne de dispositions qui contiennent un cycle.</span><span class="sxs-lookup"><span data-stu-id="04d36-247">Don't create a chain of layouts that contain a cycle.</span></span> <span data-ttu-id="04d36-248">Par exemple, ne créez pas une disposition dont la disposition est elle-même.</span><span class="sxs-lookup"><span data-stu-id="04d36-248">For example, don't create a layout whose layout is itself.</span></span>
* <span data-ttu-id="04d36-249">N’autorisez pas un utilisateur final à enfreindre les invariants de récurrence (règles) par le biais d’une entrée de données malveillante ou d’appels Interop JavaScript.</span><span class="sxs-lookup"><span data-stu-id="04d36-249">Don't allow an end user to violate recursion invariants (rules) through malicious data entry or JavaScript interop calls.</span></span>

<span data-ttu-id="04d36-250">Boucles infinies pendant le rendu :</span><span class="sxs-lookup"><span data-stu-id="04d36-250">Infinite loops during rendering:</span></span>

* <span data-ttu-id="04d36-251">Fait en sorte que le processus de rendu continue de façon permanente.</span><span class="sxs-lookup"><span data-stu-id="04d36-251">Causes the rendering process to continue forever.</span></span>
* <span data-ttu-id="04d36-252">Équivaut à créer une boucle non terminée.</span><span class="sxs-lookup"><span data-stu-id="04d36-252">Is equivalent to creating an unterminated loop.</span></span>

<span data-ttu-id="04d36-253">Dans ces scénarios, le circuit affecté se bloque et le thread tente généralement d’effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="04d36-253">In these scenarios, the affected circuit hangs, and the thread usually attempts to:</span></span>

* <span data-ttu-id="04d36-254">Consommez le plus de temps processeur autorisé par le système d’exploitation, indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="04d36-254">Consume as much CPU time as permitted by the operating system, indefinitely.</span></span>
* <span data-ttu-id="04d36-255">Consommez une quantité illimitée de mémoire serveur.</span><span class="sxs-lookup"><span data-stu-id="04d36-255">Consume an unlimited amount of server memory.</span></span> <span data-ttu-id="04d36-256">La consommation de mémoire illimitée est équivalente au scénario dans lequel une boucle non terminée ajoute des entrées à une collection à chaque itération.</span><span class="sxs-lookup"><span data-stu-id="04d36-256">Consuming unlimited memory is equivalent to the scenario where an unterminated loop adds entries to a collection on every iteration.</span></span>

<span data-ttu-id="04d36-257">Pour éviter les modèles de récurrence infinis, assurez-vous que le code de rendu récursif contient des conditions d’arrêt appropriées.</span><span class="sxs-lookup"><span data-stu-id="04d36-257">To avoid infinite recursion patterns, ensure that recursive rendering code contains suitable stopping conditions.</span></span>

### <a name="custom-render-tree-logic"></a><span data-ttu-id="04d36-258">Logique d’arborescence de rendu personnalisé</span><span class="sxs-lookup"><span data-stu-id="04d36-258">Custom render tree logic</span></span>

<span data-ttu-id="04d36-259">La plupart des composants éblouissants sont implémentés en tant que fichiers *. Razor* et sont compilés pour `RenderTreeBuilder` produire une logique qui opère sur un pour afficher leur sortie.</span><span class="sxs-lookup"><span data-stu-id="04d36-259">Most Blazor components are implemented as *.razor* files and are compiled to produce logic that operates on a `RenderTreeBuilder` to render their output.</span></span> <span data-ttu-id="04d36-260">Un développeur peut implémenter `RenderTreeBuilder` manuellement la logique C# à l’aide du code procédural.</span><span class="sxs-lookup"><span data-stu-id="04d36-260">A developer may manually implement `RenderTreeBuilder` logic using procedural C# code.</span></span> <span data-ttu-id="04d36-261">Pour plus d'informations, consultez <xref:blazor/components#manual-rendertreebuilder-logic>.</span><span class="sxs-lookup"><span data-stu-id="04d36-261">For more information, see <xref:blazor/components#manual-rendertreebuilder-logic>.</span></span>

> [!WARNING]
> <span data-ttu-id="04d36-262">L’utilisation de la logique du générateur d’arborescence de rendu manuel est considérée comme un scénario avancé et risqué, non recommandé pour le développement de composants généraux.</span><span class="sxs-lookup"><span data-stu-id="04d36-262">Use of manual render tree builder logic is considered an advanced and unsafe scenario, not recommended for general component development.</span></span>

<span data-ttu-id="04d36-263">Si `RenderTreeBuilder` le code est écrit, le développeur doit garantir l’exactitude du code.</span><span class="sxs-lookup"><span data-stu-id="04d36-263">If `RenderTreeBuilder` code is written, the developer must guarantee the correctness of the code.</span></span> <span data-ttu-id="04d36-264">Par exemple, le développeur doit s’assurer que :</span><span class="sxs-lookup"><span data-stu-id="04d36-264">For example, the developer must ensure that:</span></span>

* <span data-ttu-id="04d36-265">Les appels `OpenElement` à `CloseElement` et sont correctement équilibrés.</span><span class="sxs-lookup"><span data-stu-id="04d36-265">Calls to `OpenElement` and `CloseElement` are correctly balanced.</span></span>
* <span data-ttu-id="04d36-266">Les attributs sont ajoutés uniquement aux emplacements appropriés.</span><span class="sxs-lookup"><span data-stu-id="04d36-266">Attributes are only added in the correct places.</span></span>

<span data-ttu-id="04d36-267">Une logique incorrecte du générateur d’arborescence de rendu manuel peut entraîner un comportement arbitraire non défini, y compris des pannes, des blocages du serveur et des failles de sécurité.</span><span class="sxs-lookup"><span data-stu-id="04d36-267">Incorrect manual render tree builder logic can cause arbitrary undefined behavior, including crashes, server hangs, and security vulnerabilities.</span></span>

<span data-ttu-id="04d36-268">Envisagez une logique de générateur d’arborescence de rendu manuel sur le même niveau de complexité et avec le même niveau de *danger* que l’écriture de code assembleur ou d’instructions MSIL à la main.</span><span class="sxs-lookup"><span data-stu-id="04d36-268">Consider manual render tree builder logic on the same level of complexity and with the same level of *danger* as writing assembly code or MSIL instructions by hand.</span></span>
