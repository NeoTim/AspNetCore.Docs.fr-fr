---
title: Mettre en cache en mémoire dans ASP.NET Core
author: rick-anderson
description: Découvrez comment mettre en cache les données en mémoire dans ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 8/22/2019
uid: performance/caching/memory
ms.openlocfilehash: 23bbca5ded51d504a04415ced99ad3a6094fff6e
ms.sourcegitcommit: 41f2c1a6b316e6e368a4fd27a8b18d157cef91e1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2019
ms.locfileid: "69886453"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="efda2-103">Mettre en cache en mémoire dans ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="efda2-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="efda2-104">Par [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)et [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="efda2-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="efda2-105">[Affichez ou téléchargez l’exemple de code](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([procédure de téléchargement](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="efda2-105">[View or download sample code](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="efda2-106">Bases de la mise en cache</span><span class="sxs-lookup"><span data-stu-id="efda2-106">Caching basics</span></span>

<span data-ttu-id="efda2-107">La mise en cache peut améliorer considérablement les performances et l’évolutivité d’une application en réduisant le travail requis pour générer le contenu.</span><span class="sxs-lookup"><span data-stu-id="efda2-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="efda2-108">La mise en cache fonctionne mieux avec les données qui changent rarement **et** qui sont coûteuses à générer.</span><span class="sxs-lookup"><span data-stu-id="efda2-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="efda2-109">La mise en cache crée une copie des données qui peuvent être retournées beaucoup plus rapidement qu’à partir de la source.</span><span class="sxs-lookup"><span data-stu-id="efda2-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="efda2-110">Les applications doivent être écrites et testées pour **ne** pas dépendre des données mises en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="efda2-111">ASP.NET Core prend en charge plusieurs caches différents.</span><span class="sxs-lookup"><span data-stu-id="efda2-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="efda2-112">Le cache le plus simple est basé sur [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="efda2-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="efda2-113">`IMemoryCache`représente un cache stocké dans la mémoire du serveur Web.</span><span class="sxs-lookup"><span data-stu-id="efda2-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="efda2-114">Les applications qui s’exécutent sur une batterie de serveurs (plusieurs serveurs) doivent s’assurer que les sessions sont permanentes lors de l’utilisation du cache en mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="efda2-115">Les sessions rémanentes garantissent que les demandes d’un client vont vers le même serveur.</span><span class="sxs-lookup"><span data-stu-id="efda2-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="efda2-116">Par exemple, les applications web Azure utilisent [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) pour router toutes les demandes vers le même serveur.</span><span class="sxs-lookup"><span data-stu-id="efda2-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="efda2-117">Les sessions non rémanentes dans une batterie de serveurs web nécessitent un [cache distribué](distributed.md) pour éviter les problèmes de cohérence du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="efda2-118">Pour certaines applications, un cache distribué peut prendre en charge un sclae-out plus important qu'un cache en mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="efda2-119">Il permet de décharger la mémoire cache vers un processus externe.</span><span class="sxs-lookup"><span data-stu-id="efda2-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="efda2-120">Le cache en mémoire peut stocker n’importe quel objet.</span><span class="sxs-lookup"><span data-stu-id="efda2-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="efda2-121">L’interface du cache distribué est limitée `byte[]`à.</span><span class="sxs-lookup"><span data-stu-id="efda2-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="efda2-122">Les éléments du cache de stockage du cache distribué et en mémoire sont des paires clé-valeur.</span><span class="sxs-lookup"><span data-stu-id="efda2-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="efda2-123">System.Runtime.Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="efda2-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="efda2-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Package NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) peut être utilisé avec:</span><span class="sxs-lookup"><span data-stu-id="efda2-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="efda2-125">.NET Standard 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="efda2-126">Toute [implémentation .net](/dotnet/standard/net-standard#net-implementation-support) qui cible .NET standard 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="efda2-127">Par exemple, ASP.NET Core 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="efda2-128">.NET Framework 4,5 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="efda2-129">[Microsoft. extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (décrit dans `System.Runtime.Caching` / `MemoryCache` cet article) est recommandé, car il est mieux intégré à ASP.net core.</span><span class="sxs-lookup"><span data-stu-id="efda2-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="efda2-130">Par exemple, `IMemoryCache` fonctionne en mode natif avec [l’injection de dépendances](xref:fundamentals/dependency-injection) ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="efda2-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="efda2-131">À `System.Runtime.Caching` utiliser / entantquepontdecompatibilitélorsduPortageducodedeASP.net4.xversASP.netcore.`MemoryCache`</span><span class="sxs-lookup"><span data-stu-id="efda2-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="efda2-132">Instructions du cache</span><span class="sxs-lookup"><span data-stu-id="efda2-132">Cache guidelines</span></span>

* <span data-ttu-id="efda2-133">Le code doit toujours avoir une option de secours pour extraire les données et **ne pas** dépendre d’une valeur mise en cache disponible.</span><span class="sxs-lookup"><span data-stu-id="efda2-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="efda2-134">Le cache utilise une ressource rare, la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="efda2-135">Limiter la croissance du cache:</span><span class="sxs-lookup"><span data-stu-id="efda2-135">Limit cache growth:</span></span>
  * <span data-ttu-id="efda2-136">N’utilisez **pas** d’entrée externe comme clés de cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="efda2-137">Utilisez des expirations pour limiter la croissance du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="efda2-138">[Utilisez les paramètres, size et SizeLimit pour limiter la taille du cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="efda2-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="efda2-139">Le runtime ASP.NET Core ne limite **pas** la taille du cache en fonction de la sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="efda2-140">C’est au développeur de limiter la taille du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="efda2-141">Utiliser IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="efda2-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="efda2-142">L’utilisation d’un cache mémoire *partagé* à partir d’une `Size`injection de `SizeLimit` [dépendance](xref:fundamentals/dependency-injection) et l’appel `SetSize`de, ou pour limiter la taille du cache peuvent entraîner l’échec de l’application.</span><span class="sxs-lookup"><span data-stu-id="efda2-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="efda2-143">Quand une limite de taille est définie sur un cache, toutes les entrées doivent spécifier une taille lors de leur ajout.</span><span class="sxs-lookup"><span data-stu-id="efda2-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="efda2-144">Cela peut entraîner des problèmes, car les développeurs n’ont peut-être pas un contrôle total sur ce qui utilise le cache partagé.</span><span class="sxs-lookup"><span data-stu-id="efda2-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="efda2-145">Par exemple, Entity Framework Core utilise le cache partagé et ne spécifie pas de taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="efda2-146">Si une application définit une limite de taille de cache et utilise EF Core, l’application lève `InvalidOperationException`une exception.</span><span class="sxs-lookup"><span data-stu-id="efda2-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="efda2-147">Lorsque vous `SetSize`utilisez `Size`, ou `SizeLimit` pour limiter le cache, créez un singleton de cache pour la mise en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="efda2-148">Pour plus d’informations et pour obtenir un exemple, consultez utiliser la configuration, la [taille et SizeLimit pour limiter la taille du cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="efda2-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="efda2-149">La mise en cache en mémoire est un *service* référencé à partir d’une application à l’aide de l' [injection](xref:fundamentals/dependency-injection)de dépendances.</span><span class="sxs-lookup"><span data-stu-id="efda2-149">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="efda2-150">Faire appel à l'instance `IMemoryCache` dans le constructeur :</span><span class="sxs-lookup"><span data-stu-id="efda2-150">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="efda2-151">Le code suivant utilise [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) pour vérifier si une heure se trouve dans le cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-151">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="efda2-152">Si une heure n’est pas mis en cache, une nouvelle entrée est créée et ajoutée au cache avec [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="efda2-152">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

<span data-ttu-id="efda2-153">[! code-CSharp [] (Memory/3.0 Sample/WebCacheSample/CacheKeys. cs) [](memory/3.0sample/WebCacheSample/CacheKeys.cs)]</span><span class="sxs-lookup"><span data-stu-id="efda2-153">[!code-csharp [](memory/3.0sample/WebCacheSample/CacheKeys.cs) [](memory/3.0sample/WebCacheSample/CacheKeys.cs)]</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="efda2-154">L’heure actuelle et l’heure de mise en cache s’affichent :</span><span class="sxs-lookup"><span data-stu-id="efda2-154">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="efda2-155">La `DateTime` valeur mise en cache reste dans le cache pendant qu’il y a des requêtes dans le délai imparti.</span><span class="sxs-lookup"><span data-stu-id="efda2-155">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="efda2-156">Le code suivant utilise [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) et [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) pour mettre en cache des données.</span><span class="sxs-lookup"><span data-stu-id="efda2-156">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="efda2-157">Le code suivant appelle [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) pour extraire l’heure de mise en cache :</span><span class="sxs-lookup"><span data-stu-id="efda2-157">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="efda2-158">Le code suivant obtient ou crée un élément mis en cache avec une expiration absolue:</span><span class="sxs-lookup"><span data-stu-id="efda2-158">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="efda2-159">Un ensemble d’éléments mis en cache avec expiration décalée est menacé pour devenir obsolète, car il n’y a aucune limite à son expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-159">A cached item set with sliding expiration only is at risk for becoming stale because there is no bound to its expiration.</span></span> <span data-ttu-id="efda2-160">Utilisez une expiration absolue avec une expiration décalée pour garantir que l’élément mis en cache ne deviendra pas plus obsolète que l’expiration absolue.</span><span class="sxs-lookup"><span data-stu-id="efda2-160">Use an absolute expiration with a sliding expiration to guarantee the cached item won't become more stale than the absolute expiration.</span></span> <span data-ttu-id="efda2-161">Lorsque l’expiration absolue est combinée avec le glissement, l’expiration absolue définit une limite supérieure à la durée pendant laquelle l’élément peut être mis en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-161">When absolute expiration is combined with sliding, the absolute expiration sets an upper bound to how long the item can be cached.</span></span> <span data-ttu-id="efda2-162">Contrairement à l’heure d’expiration absolue uniquement, si l’élément n’est pas demandé dans le cache au cours de l’intervalle d’expiration décalé, l’élément est supprimé du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-162">Unlike absolute expiration time alone, if the item is not requested from the cache within the sliding expiration interval, the item is evicted from the cache.</span></span> <span data-ttu-id="efda2-163">Lorsque l’expiration absolue et décalée est spécifiée, les expirations sont logiquement associées.</span><span class="sxs-lookup"><span data-stu-id="efda2-163">When absolute and sliding expiration is specified, the expirations are logically ORed.</span></span>

<span data-ttu-id="efda2-164">Le code suivant obtient ou crée un élément mis en cache avec une expiration décalée et absolue:</span><span class="sxs-lookup"><span data-stu-id="efda2-164">The following code gets or creates a cached item with sliding and absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="efda2-165">Le code précédent garantit que les données ne seront pas mises en cache plus longtemps que l’heure absolue.</span><span class="sxs-lookup"><span data-stu-id="efda2-165">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="efda2-166"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>et <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> sont des méthodes d’extension qui font partie de la classe qui étend la fonctionnalité de.</span><span class="sxs-lookup"><span data-stu-id="efda2-166"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods part of the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="efda2-167">Pour obtenir une description des autres méthodes de cache, consultez [méthodes IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) et [méthodes CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) .</span><span class="sxs-lookup"><span data-stu-id="efda2-167">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="efda2-168">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="efda2-168">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="efda2-169">L’exemple suivant:</span><span class="sxs-lookup"><span data-stu-id="efda2-169">The following sample:</span></span>

* <span data-ttu-id="efda2-170">Définit un délai d’expiration glissant.</span><span class="sxs-lookup"><span data-stu-id="efda2-170">Sets a sliding expiration time.</span></span> <span data-ttu-id="efda2-171">Les requêtes qui accèdent à cet élément de mise en cache réinitialisent l’horloge d’expiration glissante.</span><span class="sxs-lookup"><span data-stu-id="efda2-171">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="efda2-172">Définit la priorité du cache sur [CacheItemPriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="efda2-172">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="efda2-173">Définit un [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) qui est appelé après la suppression de l’entrée du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-173">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="efda2-174">Le rappel est exécuté sur un thread différent du code qui supprime l’élément à partir du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-174">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="efda2-175">Utiliser SetSize, Size et SizeLimit pour limiter la taille du cache</span><span class="sxs-lookup"><span data-stu-id="efda2-175">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="efda2-176">Une instance `MemoryCache` peut éventuellement spécifier et appliquer une limite de taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-176">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="efda2-177">La limite de taille de mémoire n’a pas d’unité de mesure, car le cache dispose d’aucun mécanisme pour mesurer le nombre d’entrées.</span><span class="sxs-lookup"><span data-stu-id="efda2-177">The memory size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="efda2-178">Si la limite de taille de la mémoire cache est définie, toutes les entrées doivent spécifier la taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-178">If the cache memory size limit is set, all entries must specify size.</span></span> <span data-ttu-id="efda2-179">Le runtime ASP.NET Core ne limite pas la taille du cache en fonction de la sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-179">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="efda2-180">C’est au développeur de limiter la taille du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-180">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="efda2-181">La taille spécifiée est exprimé en unités choisies par le développeur.</span><span class="sxs-lookup"><span data-stu-id="efda2-181">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="efda2-182">Exemple :</span><span class="sxs-lookup"><span data-stu-id="efda2-182">For example:</span></span>

* <span data-ttu-id="efda2-183">Si l’application web met en cache principalement les chaînes, chaque taille d’entrée du cache peut être la longueur de chaîne.</span><span class="sxs-lookup"><span data-stu-id="efda2-183">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="efda2-184">L’application peut spécifier la taille de toutes les entrées en tant que 1, et la limite de taille est le nombre d’entrées.</span><span class="sxs-lookup"><span data-stu-id="efda2-184">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="efda2-185">Si <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> n’est pas défini, le cache croît sans limite.</span><span class="sxs-lookup"><span data-stu-id="efda2-185">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="efda2-186">Le runtime ASP.NET Core ne supprime pas le cache lorsque la mémoire système est insuffisante.</span><span class="sxs-lookup"><span data-stu-id="efda2-186">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="efda2-187">Les applications sont en grande partie conçues pour:</span><span class="sxs-lookup"><span data-stu-id="efda2-187">Apps much be architected to:</span></span>

* <span data-ttu-id="efda2-188">Limiter la croissance du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-188">Limit cache growth.</span></span>
* <span data-ttu-id="efda2-189">Appelez <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> ou<xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> lorsque la mémoire disponible est limitée:</span><span class="sxs-lookup"><span data-stu-id="efda2-189">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="efda2-190">Le code suivant crée une taille <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> fixe sans unité accessible par [injection de dépendances](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="efda2-190">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="efda2-191">`SizeLimit`n’a pas d’unités.</span><span class="sxs-lookup"><span data-stu-id="efda2-191">`SizeLimit` does not have units.</span></span> <span data-ttu-id="efda2-192">Les entrées mises en cache doivent indiquer la taille dans les unités jugées les plus appropriées si la taille de la mémoire cache a été définie.</span><span class="sxs-lookup"><span data-stu-id="efda2-192">Cached entries must specify size in whatever units they deem most appropriate if the cache memory size has been set.</span></span> <span data-ttu-id="efda2-193">Tous les utilisateurs d’une instance de cache doivent utiliser le même système d’unité.</span><span class="sxs-lookup"><span data-stu-id="efda2-193">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="efda2-194">Une entrée n’est pas mise en cache si la somme des tailles des entrées mises en cache dépasse la valeur spécifiée par `SizeLimit`.</span><span class="sxs-lookup"><span data-stu-id="efda2-194">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="efda2-195">Si aucune limite de taille du cache n’est définie, la taille de cache définie sur l’entrée est ignorée.</span><span class="sxs-lookup"><span data-stu-id="efda2-195">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="efda2-196">Le code suivant inscrit `MyMemoryCache` avec le conteneur [d’injection de dépendances](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="efda2-196">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="efda2-197">`MyMemoryCache` est créé comme cache de mémoire indépendant pour les composants qui sont informés de la taille limitée du cache et qui ont la capacité de définir une taille d’entrée de cache en conséquence.</span><span class="sxs-lookup"><span data-stu-id="efda2-197">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="efda2-198">Le code suivant utilise `MyMemoryCache`:</span><span class="sxs-lookup"><span data-stu-id="efda2-198">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="efda2-199">La taille de l’entrée de cache peut être définie <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> par ou <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> par les méthodes d’extension:</span><span class="sxs-lookup"><span data-stu-id="efda2-199">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="efda2-200">MemoryCache. compact</span><span class="sxs-lookup"><span data-stu-id="efda2-200">MemoryCache.Compact</span></span>

<span data-ttu-id="efda2-201">`MemoryCache.Compact`tente de supprimer le pourcentage spécifié du cache dans l’ordre suivant:</span><span class="sxs-lookup"><span data-stu-id="efda2-201">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="efda2-202">Tous les éléments arrivés à expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-202">All expired items.</span></span>
* <span data-ttu-id="efda2-203">Éléments par priorité.</span><span class="sxs-lookup"><span data-stu-id="efda2-203">Items by priority.</span></span> <span data-ttu-id="efda2-204">Les éléments de priorité la plus basse sont supprimés en premier.</span><span class="sxs-lookup"><span data-stu-id="efda2-204">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="efda2-205">Objets utilisés le moins récemment.</span><span class="sxs-lookup"><span data-stu-id="efda2-205">Least recently used objects.</span></span>
* <span data-ttu-id="efda2-206">Éléments avec l’expiration absolue la plus ancienne.</span><span class="sxs-lookup"><span data-stu-id="efda2-206">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="efda2-207">Éléments avec l’expiration décalée la plus ancienne.</span><span class="sxs-lookup"><span data-stu-id="efda2-207">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="efda2-208">Les éléments épinglés <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> avec priorité ne sont jamais supprimés.</span><span class="sxs-lookup"><span data-stu-id="efda2-208">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="efda2-209">Le code suivant supprime un élément de cache et `Compact`appelle:</span><span class="sxs-lookup"><span data-stu-id="efda2-209">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="efda2-210">Pour plus d’informations, consultez [source compact sur GitHub](https://github.com/aspnet/Extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="efda2-210">See [Compact source on GitHub](https://github.com/aspnet/Extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="efda2-211">Dépendances de cache</span><span class="sxs-lookup"><span data-stu-id="efda2-211">Cache dependencies</span></span>

<span data-ttu-id="efda2-212">L’exemple suivant montre comment expirer une entrée de cache si une entrée dépendante expire.</span><span class="sxs-lookup"><span data-stu-id="efda2-212">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="efda2-213">Un `CancellationChangeToken` est ajouté à l’élément mis en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-213">A `CancellationChangeToken` is added to the cached item.</span></span> <span data-ttu-id="efda2-214">Lorsque `Cancel` est appelée sur le `CancellationTokenSource`, les deux entrées du cache sont supprimées.</span><span class="sxs-lookup"><span data-stu-id="efda2-214">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="efda2-215">Utiliser un `CancellationTokenSource` permet à plusieurs entrées de cache d'être supprimées en tant que groupe.</span><span class="sxs-lookup"><span data-stu-id="efda2-215">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="efda2-216">Avec le modèle `using` dans le code ci-dessus, les entrées de cache créées à l’intérieur du bloc `using` hériteront des déclencheurs et des paramètres d’expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-216">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="efda2-217">Remarques supplémentaires</span><span class="sxs-lookup"><span data-stu-id="efda2-217">Additional notes</span></span>

* <span data-ttu-id="efda2-218">L’expiration ne se produit pas en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="efda2-218">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="efda2-219">Il n’existe pas de minuteur qui analyse activement le cache à la recherche d’éléments arrivés à expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-219">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="efda2-220">Toute activité sur le cache (`Get`, `Set`, `Remove`) peut déclencher une analyse en arrière-plan des éléments arrivés à expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-220">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="efda2-221">Un minuteur sur `CancellationTokenSource` (`CancelAfter`) supprimerait également l’entrée et déclenchera une analyse des éléments arrivés à expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-221">A timer on the `CancellationTokenSource` (`CancelAfter`) would also remove the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="efda2-222">Par exemple, au lieu `SetAbsoluteExpiration(TimeSpan.FromHours(1))`d’utiliser, utilisez `CancellationTokenSource.CancelAfter(TimeSpan.FromHours(1))` pour le jeton inscrit.</span><span class="sxs-lookup"><span data-stu-id="efda2-222">For example, rather than using `SetAbsoluteExpiration(TimeSpan.FromHours(1))`, use `CancellationTokenSource.CancelAfter(TimeSpan.FromHours(1))` for the registered token.</span></span> <span data-ttu-id="efda2-223">Quand ce jeton est activé, il supprime immédiatement l’entrée et déclenche les rappels d’éviction.</span><span class="sxs-lookup"><span data-stu-id="efda2-223">When this token fires it removes the entry immediately and fires the eviction callbacks.</span></span> <span data-ttu-id="efda2-224">Pour plus d’informations, consultez [ce problème GitHub](https://github.com/aspnet/Caching/issues/248).</span><span class="sxs-lookup"><span data-stu-id="efda2-224">For more information, see [this GitHub issue](https://github.com/aspnet/Caching/issues/248).</span></span>
* <span data-ttu-id="efda2-225">Lorsque vous utilisez un rappel pour remplir un élément de cache :</span><span class="sxs-lookup"><span data-stu-id="efda2-225">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="efda2-226">Plusieurs demandes peuvent trouver la valeur de clé mise en cache vide étant donné que le rappel n’est pas terminé.</span><span class="sxs-lookup"><span data-stu-id="efda2-226">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="efda2-227">Il peut en résulter que plusieurs threads remplissent l’élément mis en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-227">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="efda2-228">Lorsqu’une entrée de cache est utilisée pour en créer une autre, l’enfant copie les jetons d’expiration et les paramètres d’expiration basés sur le temps de l’entrée parente.</span><span class="sxs-lookup"><span data-stu-id="efda2-228">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="efda2-229">L’enfant n’est pas expiré par la suppression manuelle ou à la mise à jour de l’entrée parente.</span><span class="sxs-lookup"><span data-stu-id="efda2-229">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="efda2-230">Utilisez <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> pour définir les rappels qui seront déclenchés après que l’entrée du cache a été supprimée du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-230">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="efda2-231">Pour la plupart des `IMemoryCache` applications, est activé.</span><span class="sxs-lookup"><span data-stu-id="efda2-231">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="efda2-232">Par exemple, l' `AddMvc`appel `AddControllersWithViews`de `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`,,, et `Add{Service}` de nombreuses `ConfigureServices`autres méthodes `IMemoryCache`dans, active.</span><span class="sxs-lookup"><span data-stu-id="efda2-232">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="efda2-233">Pour les applications qui n’appellent pas l’une des `Add{Service}` méthodes précédentes, il peut être nécessaire d' <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> appeler `ConfigureServices`dans.</span><span class="sxs-lookup"><span data-stu-id="efda2-233">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="efda2-234">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="efda2-234">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="efda2-235">Par [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)et [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="efda2-235">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="efda2-236">[Affichez ou téléchargez l’exemple de code](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([procédure de téléchargement](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="efda2-236">[View or download sample code](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="efda2-237">Bases de la mise en cache</span><span class="sxs-lookup"><span data-stu-id="efda2-237">Caching basics</span></span>

<span data-ttu-id="efda2-238">La mise en cache peut améliorer considérablement les performances et l’évolutivité d’une application en réduisant le travail requis pour générer le contenu.</span><span class="sxs-lookup"><span data-stu-id="efda2-238">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="efda2-239">Elle est idéale pour les données qui ne sont pas souvent modifiées.</span><span class="sxs-lookup"><span data-stu-id="efda2-239">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="efda2-240">Elle effectue une copie des données, qui sont ainsi renvoyées beaucoup plus rapidement qu’à partir de la source d’origine.</span><span class="sxs-lookup"><span data-stu-id="efda2-240">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="efda2-241">Le code doit être écrit et testé pour **ne** pas dépendre des données mises en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-241">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="efda2-242">ASP.NET Core prend en charge plusieurs caches différents.</span><span class="sxs-lookup"><span data-stu-id="efda2-242">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="efda2-243">Le cache le plus simple est basé sur le [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), qui représente un cache stocké dans la mémoire du serveur web.</span><span class="sxs-lookup"><span data-stu-id="efda2-243">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="efda2-244">Les applications qui s’exécutent sur une batterie de serveurs (plusieurs serveurs) doivent s’assurer que les sessions sont permanentes lors de l’utilisation du cache en mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-244">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="efda2-245">Les sessions rémanentes garantissent que les demandes ultérieures provenant d’un client sont toutes dirigées vers le même serveur.</span><span class="sxs-lookup"><span data-stu-id="efda2-245">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="efda2-246">Par exemple, Azure Web Apps utilise [application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (arr) pour acheminer toutes les demandes d’un agent utilisateur vers le même serveur.</span><span class="sxs-lookup"><span data-stu-id="efda2-246">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="efda2-247">Les sessions non rémanentes dans une batterie de serveurs web nécessitent un [cache distribué](distributed.md) pour éviter les problèmes de cohérence du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-247">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="efda2-248">Pour certaines applications, un cache distribué peut prendre en charge un sclae-out plus important qu'un cache en mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-248">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="efda2-249">Il permet de décharger la mémoire cache vers un processus externe.</span><span class="sxs-lookup"><span data-stu-id="efda2-249">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="efda2-250">Le cache en mémoire peut stocker n’importe quel objet.</span><span class="sxs-lookup"><span data-stu-id="efda2-250">The in-memory cache can store any object.</span></span> <span data-ttu-id="efda2-251">L’interface du cache distribué est limitée `byte[]`à.</span><span class="sxs-lookup"><span data-stu-id="efda2-251">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="efda2-252">Les éléments du cache de stockage du cache distribué et en mémoire sont des paires clé-valeur.</span><span class="sxs-lookup"><span data-stu-id="efda2-252">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="efda2-253">System.Runtime.Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="efda2-253">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="efda2-254"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Package NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) peut être utilisé avec:</span><span class="sxs-lookup"><span data-stu-id="efda2-254"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="efda2-255">.NET Standard 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-255">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="efda2-256">Toute [implémentation .net](/dotnet/standard/net-standard#net-implementation-support) qui cible .NET standard 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-256">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="efda2-257">Par exemple, ASP.NET Core 2,0 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-257">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="efda2-258">.NET Framework 4,5 ou version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="efda2-258">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="efda2-259">[Microsoft. extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (décrit dans `System.Runtime.Caching` / `MemoryCache` cet article) est recommandé, car il est mieux intégré à ASP.net core.</span><span class="sxs-lookup"><span data-stu-id="efda2-259">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="efda2-260">Par exemple, `IMemoryCache` fonctionne en mode natif avec [l’injection de dépendances](xref:fundamentals/dependency-injection) ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="efda2-260">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="efda2-261">À `System.Runtime.Caching` utiliser / entantquepontdecompatibilitélorsduPortageducodedeASP.net4.xversASP.netcore.`MemoryCache`</span><span class="sxs-lookup"><span data-stu-id="efda2-261">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="efda2-262">Instructions du cache</span><span class="sxs-lookup"><span data-stu-id="efda2-262">Cache guidelines</span></span>

* <span data-ttu-id="efda2-263">Le code doit toujours avoir une option de secours pour extraire les données et **ne pas** dépendre d’une valeur mise en cache disponible.</span><span class="sxs-lookup"><span data-stu-id="efda2-263">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="efda2-264">Le cache utilise une ressource rare, la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-264">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="efda2-265">Limiter la croissance du cache:</span><span class="sxs-lookup"><span data-stu-id="efda2-265">Limit cache growth:</span></span>
  * <span data-ttu-id="efda2-266">N’utilisez **pas** d’entrée externe comme clés de cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-266">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="efda2-267">Utilisez des expirations pour limiter la croissance du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-267">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="efda2-268">[Utilisez les paramètres, size et SizeLimit pour limiter la taille du cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="efda2-268">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="efda2-269">Le runtime ASP.NET Core ne limite pas la taille du cache en fonction de la sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-269">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="efda2-270">C’est au développeur de limiter la taille du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-270">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="efda2-271">Utilisation de IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="efda2-271">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="efda2-272">L’utilisation d’un cache mémoire *partagé* à partir d’une `Size`injection de `SizeLimit` [dépendance](xref:fundamentals/dependency-injection) et l’appel `SetSize`de, ou pour limiter la taille du cache peuvent entraîner l’échec de l’application.</span><span class="sxs-lookup"><span data-stu-id="efda2-272">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="efda2-273">Quand une limite de taille est définie sur un cache, toutes les entrées doivent spécifier une taille lors de leur ajout.</span><span class="sxs-lookup"><span data-stu-id="efda2-273">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="efda2-274">Cela peut entraîner des problèmes, car les développeurs n’ont peut-être pas un contrôle total sur ce qui utilise le cache partagé.</span><span class="sxs-lookup"><span data-stu-id="efda2-274">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="efda2-275">Par exemple, Entity Framework Core utilise le cache partagé et ne spécifie pas de taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-275">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="efda2-276">Si une application définit une limite de taille de cache et utilise EF Core, l’application lève `InvalidOperationException`une exception.</span><span class="sxs-lookup"><span data-stu-id="efda2-276">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="efda2-277">Lorsque vous `SetSize`utilisez `Size`, ou `SizeLimit` pour limiter le cache, créez un singleton de cache pour la mise en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-277">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="efda2-278">Pour plus d’informations et pour obtenir un exemple, consultez utiliser la configuration, la [taille et SizeLimit pour limiter la taille du cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="efda2-278">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="efda2-279">La mise en cache en mémoire est un *service* qui est référencé à partir de votre application à l’aide de l'[Injection de dépendance](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="efda2-279">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="efda2-280">Appelez `AddMemoryCache` dans `ConfigureServices`:</span><span class="sxs-lookup"><span data-stu-id="efda2-280">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="efda2-281">Faire appel à l'instance `IMemoryCache` dans le constructeur :</span><span class="sxs-lookup"><span data-stu-id="efda2-281">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="efda2-282">`IMemoryCache`requiert le package NuGet [Microsoft. extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), qui est disponible dans le [produit Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="efda2-282">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="efda2-283">Le code suivant utilise [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) pour vérifier si une heure se trouve dans le cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-283">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="efda2-284">Si une heure n’est pas mis en cache, une nouvelle entrée est créée et ajoutée au cache avec [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="efda2-284">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

<span data-ttu-id="efda2-285">[! code-CSharp [] (mémoire/exemple/WEBCACHE/CacheKeys. cs) [](memory/sample/WebCache/CacheKeys.cs)]</span><span class="sxs-lookup"><span data-stu-id="efda2-285">[!code-csharp [](memory/sample/WebCache/CacheKeys.cs) [](memory/sample/WebCache/CacheKeys.cs)]</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="efda2-286">L’heure actuelle et l’heure de mise en cache s’affichent :</span><span class="sxs-lookup"><span data-stu-id="efda2-286">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="efda2-287">La `DateTime` valeur mise en cache reste dans le cache pendant qu’il y a des requêtes dans le délai imparti.</span><span class="sxs-lookup"><span data-stu-id="efda2-287">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="efda2-288">L’illustration ci-dessous indique l’heure actuelle et une heure antérieure récupérées du cache :</span><span class="sxs-lookup"><span data-stu-id="efda2-288">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Vue d’index avec deux heures différentes affichées](memory/_static/time.png)

<span data-ttu-id="efda2-290">Le code suivant utilise [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) et [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) pour mettre en cache des données.</span><span class="sxs-lookup"><span data-stu-id="efda2-290">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="efda2-291">Le code suivant appelle [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) pour extraire l’heure de mise en cache :</span><span class="sxs-lookup"><span data-stu-id="efda2-291">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="efda2-292"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> et [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) sont des méthodes d’extension qui font partie de la classe [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) qui étend la fonctionnalité de <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span><span class="sxs-lookup"><span data-stu-id="efda2-292"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="efda2-293">Pour obtenir une description des autres méthodes de cache, consultez [méthodes IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) et [méthodes CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) .</span><span class="sxs-lookup"><span data-stu-id="efda2-293">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="efda2-294">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="efda2-294">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="efda2-295">L’exemple suivant:</span><span class="sxs-lookup"><span data-stu-id="efda2-295">The following sample:</span></span>

* <span data-ttu-id="efda2-296">Définit un délai d’expiration glissant.</span><span class="sxs-lookup"><span data-stu-id="efda2-296">Sets a sliding expiration time.</span></span> <span data-ttu-id="efda2-297">Les requêtes qui accèdent à cet élément de mise en cache réinitialisent l’horloge d’expiration glissante.</span><span class="sxs-lookup"><span data-stu-id="efda2-297">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="efda2-298">Affecte à la priorité de `CacheItemPriority.NeverRemove`cache la valeur.</span><span class="sxs-lookup"><span data-stu-id="efda2-298">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="efda2-299">Définit un [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) qui est appelé après la suppression de l’entrée du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-299">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="efda2-300">Le rappel est exécuté sur un thread différent du code qui supprime l’élément à partir du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-300">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="efda2-301">Utiliser SetSize, Size et SizeLimit pour limiter la taille du cache</span><span class="sxs-lookup"><span data-stu-id="efda2-301">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="efda2-302">Une instance `MemoryCache` peut éventuellement spécifier et appliquer une limite de taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-302">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="efda2-303">La limite de taille de mémoire n’a pas d’unité de mesure, car le cache dispose d’aucun mécanisme pour mesurer le nombre d’entrées.</span><span class="sxs-lookup"><span data-stu-id="efda2-303">The memory size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="efda2-304">Si la limite de taille de la mémoire cache est définie, toutes les entrées doivent spécifier la taille.</span><span class="sxs-lookup"><span data-stu-id="efda2-304">If the cache memory size limit is set, all entries must specify size.</span></span> <span data-ttu-id="efda2-305">Le runtime ASP.NET Core ne limite pas la taille du cache en fonction de la sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="efda2-305">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="efda2-306">C’est au développeur de limiter la taille du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-306">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="efda2-307">La taille spécifiée est exprimé en unités choisies par le développeur.</span><span class="sxs-lookup"><span data-stu-id="efda2-307">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="efda2-308">Exemple :</span><span class="sxs-lookup"><span data-stu-id="efda2-308">For example:</span></span>

* <span data-ttu-id="efda2-309">Si l’application web met en cache principalement les chaînes, chaque taille d’entrée du cache peut être la longueur de chaîne.</span><span class="sxs-lookup"><span data-stu-id="efda2-309">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="efda2-310">L’application peut spécifier la taille de toutes les entrées en tant que 1, et la limite de taille est le nombre d’entrées.</span><span class="sxs-lookup"><span data-stu-id="efda2-310">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="efda2-311">Si <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> n’est pas défini, le cache croît sans limite.</span><span class="sxs-lookup"><span data-stu-id="efda2-311">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="efda2-312">Le runtime ASP.NET Core ne supprime pas le cache lorsque la mémoire système est insuffisante.</span><span class="sxs-lookup"><span data-stu-id="efda2-312">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="efda2-313">Les applications sont en grande partie conçues pour:</span><span class="sxs-lookup"><span data-stu-id="efda2-313">Apps much be architected to:</span></span>

* <span data-ttu-id="efda2-314">Limiter la croissance du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-314">Limit cache growth.</span></span>
* <span data-ttu-id="efda2-315">Appelez <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> ou<xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> lorsque la mémoire disponible est limitée:</span><span class="sxs-lookup"><span data-stu-id="efda2-315">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="efda2-316">Le code suivant crée une taille <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> fixe sans unité accessible par [injection de dépendances](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="efda2-316">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="efda2-317">`SizeLimit`n’a pas d’unités.</span><span class="sxs-lookup"><span data-stu-id="efda2-317">`SizeLimit` does not have units.</span></span> <span data-ttu-id="efda2-318">Les entrées mises en cache doivent indiquer la taille dans les unités jugées les plus appropriées si la taille de la mémoire cache a été définie.</span><span class="sxs-lookup"><span data-stu-id="efda2-318">Cached entries must specify size in whatever units they deem most appropriate if the cache memory size has been set.</span></span> <span data-ttu-id="efda2-319">Tous les utilisateurs d’une instance de cache doivent utiliser le même système d’unité.</span><span class="sxs-lookup"><span data-stu-id="efda2-319">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="efda2-320">Une entrée n’est pas mise en cache si la somme des tailles des entrées mises en cache dépasse la valeur spécifiée par `SizeLimit`.</span><span class="sxs-lookup"><span data-stu-id="efda2-320">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="efda2-321">Si aucune limite de taille du cache n’est définie, la taille de cache définie sur l’entrée est ignorée.</span><span class="sxs-lookup"><span data-stu-id="efda2-321">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="efda2-322">Le code suivant inscrit `MyMemoryCache` avec le conteneur [d’injection de dépendances](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="efda2-322">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="efda2-323">`MyMemoryCache` est créé comme cache de mémoire indépendant pour les composants qui sont informés de la taille limitée du cache et qui ont la capacité de définir une taille d’entrée de cache en conséquence.</span><span class="sxs-lookup"><span data-stu-id="efda2-323">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="efda2-324">Le code suivant utilise `MyMemoryCache`:</span><span class="sxs-lookup"><span data-stu-id="efda2-324">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="efda2-325">La taille de l’entrée de cache peut être définie par [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) ou par la méthode d’extension [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="efda2-325">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="efda2-326">MemoryCache. compact</span><span class="sxs-lookup"><span data-stu-id="efda2-326">MemoryCache.Compact</span></span>

<span data-ttu-id="efda2-327">`MemoryCache.Compact`tente de supprimer le pourcentage spécifié du cache dans l’ordre suivant:</span><span class="sxs-lookup"><span data-stu-id="efda2-327">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="efda2-328">Tous les éléments arrivés à expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-328">All expired items.</span></span>
* <span data-ttu-id="efda2-329">Éléments par priorité.</span><span class="sxs-lookup"><span data-stu-id="efda2-329">Items by priority.</span></span> <span data-ttu-id="efda2-330">Les éléments de priorité la plus basse sont supprimés en premier.</span><span class="sxs-lookup"><span data-stu-id="efda2-330">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="efda2-331">Objets utilisés le moins récemment.</span><span class="sxs-lookup"><span data-stu-id="efda2-331">Least recently used objects.</span></span>
* <span data-ttu-id="efda2-332">Éléments avec l’expiration absolue la plus ancienne.</span><span class="sxs-lookup"><span data-stu-id="efda2-332">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="efda2-333">Éléments avec l’expiration décalée la plus ancienne.</span><span class="sxs-lookup"><span data-stu-id="efda2-333">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="efda2-334">Les éléments épinglés <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> avec priorité ne sont jamais supprimés.</span><span class="sxs-lookup"><span data-stu-id="efda2-334">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="efda2-335">Pour plus d’informations, consultez [source compact sur GitHub](https://github.com/aspnet/Extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="efda2-335">See [Compact source on GitHub](https://github.com/aspnet/Extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="efda2-336">Dépendances de cache</span><span class="sxs-lookup"><span data-stu-id="efda2-336">Cache dependencies</span></span>

<span data-ttu-id="efda2-337">L’exemple suivant montre comment expirer une entrée de cache si une entrée dépendante expire.</span><span class="sxs-lookup"><span data-stu-id="efda2-337">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="efda2-338">Un `CancellationChangeToken` est ajouté à l’élément mis en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-338">A `CancellationChangeToken` is added to the cached item.</span></span> <span data-ttu-id="efda2-339">Lorsque `Cancel` est appelée sur le `CancellationTokenSource`, les deux entrées du cache sont supprimées.</span><span class="sxs-lookup"><span data-stu-id="efda2-339">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="efda2-340">Utiliser un `CancellationTokenSource` permet à plusieurs entrées de cache d'être supprimées en tant que groupe.</span><span class="sxs-lookup"><span data-stu-id="efda2-340">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="efda2-341">Avec le modèle `using` dans le code ci-dessus, les entrées de cache créées à l’intérieur du bloc `using` hériteront des déclencheurs et des paramètres d’expiration.</span><span class="sxs-lookup"><span data-stu-id="efda2-341">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="efda2-342">Remarques supplémentaires</span><span class="sxs-lookup"><span data-stu-id="efda2-342">Additional notes</span></span>

* <span data-ttu-id="efda2-343">Lorsque vous utilisez un rappel pour remplir un élément de cache :</span><span class="sxs-lookup"><span data-stu-id="efda2-343">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="efda2-344">Plusieurs demandes peuvent trouver la valeur de clé mise en cache vide étant donné que le rappel n’est pas terminé.</span><span class="sxs-lookup"><span data-stu-id="efda2-344">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="efda2-345">Il peut en résulter que plusieurs threads remplissent l’élément mis en cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-345">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="efda2-346">Lorsqu’une entrée de cache est utilisée pour en créer une autre, l’enfant copie les jetons d’expiration et les paramètres d’expiration basés sur le temps de l’entrée parente.</span><span class="sxs-lookup"><span data-stu-id="efda2-346">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="efda2-347">L’enfant n’est pas expiré par la suppression manuelle ou à la mise à jour de l’entrée parente.</span><span class="sxs-lookup"><span data-stu-id="efda2-347">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="efda2-348">Utilisez [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) pour définir que les rappels sont déclenchés une fois que l’entrée de cache est supprimée du cache.</span><span class="sxs-lookup"><span data-stu-id="efda2-348">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="efda2-349">Ressources supplémentaires</span><span class="sxs-lookup"><span data-stu-id="efda2-349">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
